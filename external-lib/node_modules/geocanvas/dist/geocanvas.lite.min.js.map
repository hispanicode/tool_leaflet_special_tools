{"version":3,"file":"geocanvas.lite.min.js","mappings":"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","sources":["webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/calculate-core.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/calculate.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/categorize-intersection.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/check-rows.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/clamp.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/cluster-line-segments.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/cluster.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/couple.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/each-edge.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/each-polygon.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/get-bounding-box.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/get-edges.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/get-intersection-of-two-lines.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/get-line-from-points.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/get-polygons.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/index.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/merge-consecutive-ranges.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/merge-ranges.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/partition.js","webpack://geocanvas/./node_modules/.pnpm/dufour-peyton-intersection@0.1.1/node_modules/dufour-peyton-intersection/src/range.js","webpack://geocanvas/./node_modules/.pnpm/geomask@0.3.5/node_modules/geomask/lite.js","webpack://geocanvas/./node_modules/.pnpm/get-depth@0.0.3/node_modules/get-depth/index.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/absolute.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/add.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/clean.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/compare_positive.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/divide.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/expand.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/long_addition.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/long_division.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/long_multiplication.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/long_subtraction.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/multiply.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/round_last_decimal.js","webpack://geocanvas/./node_modules/.pnpm/preciso@0.2.0/node_modules/preciso/subtract.js","webpack://geocanvas/./node_modules/.pnpm/reproject-geojson@0.1.2/node_modules/reproject-geojson/pluggable.js","webpack://geocanvas/./node_modules/.pnpm/segflip@0.0.2/node_modules/segflip/segflip.js","webpack://geocanvas/./src/core.js","webpack://geocanvas/./src/lite.js","webpack://geocanvas/webpack/bootstrap","webpack://geocanvas/webpack/startup"],"sourcesContent":["const getLineFromPoints = require(\"./get-line-from-points.js\");\nconst categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst couple = require(\"./couple.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst getEdges = require(\"./get-edges.js\");\nconst getIntersectionOfTwoLines = require(\"./get-intersection-of-two-lines.js\");\nconst getPolygons = require(\"./get-polygons.js\");\nconst mergeRanges = require(\"./merge-ranges.js\");\nconst partition = require(\"./partition.js\");\nconst range = require(\"./range.js\");\n\nmodule.exports = function calculateCore({ raster_bbox, raster_height, raster_width, pixel_height, pixel_width, geometry, per_pixel, per_row_segment }) {\n  const [raster_xmin, raster_ymin, raster_xmax, raster_ymax] = raster_bbox;\n\n  // iterate through image rows and convert each one to a line\n  // running through the middle of the row\n  const imageLines = [];\n\n  if (raster_height === 0) return;\n\n  for (let y = 0; y < raster_height; y++) {\n    const lat = raster_ymax - pixel_height * y - pixel_height / 2;\n\n    // use that point, plus another point along the same latitude to\n    // create a line\n    const point0 = [raster_xmin, lat];\n    const point1 = [raster_xmin + 1, lat];\n    const line = getLineFromPoints(point0, point1);\n    imageLines.push(line);\n  }\n\n  // collapse geometry down to a list of edges\n  // necessary for multi-part geometries\n  const polygons = getPolygons(geometry);\n  const polygonEdges = polygons.map(getEdges);\n\n  polygonEdges.forEach(edges => {\n    // iterate through the list of polygon vertices, convert them to\n    // lines, and compute the intersections with each image row\n    const intersectionsByRow = range(raster_height).map(() => []);\n    const numberOfEdges = edges.length;\n    for (let i = 0; i < numberOfEdges; i++) {\n      // get vertices that make up an edge and convert that to a line\n      const edge = edges[i];\n\n      const [startPoint, endPoint] = edge;\n      const [x1, y1] = startPoint;\n      const [x2, y2] = endPoint;\n\n      const direction = Math.sign(y2 - y1);\n      const horizontal = y1 === y2;\n      const vertical = x1 === x2;\n\n      const edgeY = y1;\n\n      const edgeLine = getLineFromPoints(startPoint, endPoint);\n\n      const edgeYMin = Math.min(y1, y2);\n      const edgeYMax = Math.max(y1, y2);\n\n      let startLng, startLat, endLat, endLng;\n      if (x1 < x2) {\n        [startLng, startLat] = startPoint;\n        [endLng, endLat] = endPoint;\n      } else {\n        [startLng, startLat] = endPoint;\n        [endLng, endLat] = startPoint;\n      }\n\n      if (startLng === undefined) throw Error(\"startLng is \" + startLng);\n\n      // find the y values in the image coordinate space\n      const imageY1 = Math.round((raster_bbox[3] - 0.5 * pixel_height - startLat) / pixel_height);\n      const imageY2 = Math.round((raster_bbox[3] - 0.5 * pixel_height - endLat) / pixel_height);\n\n      // make sure to set the start and end points so that we are\n      // incrementing upwards through rows\n      let rowStart, rowEnd;\n      if (imageY1 < imageY2) {\n        rowStart = imageY1;\n        rowEnd = imageY2;\n      } else {\n        rowStart = imageY2;\n        rowEnd = imageY1;\n      }\n\n      rowStart = clamp(rowStart, 0, raster_height - 1);\n      rowEnd = clamp(rowEnd, 0, raster_height - 1);\n      // iterate through image lines within the change in y of\n      // the edge line and find all intersections\n      for (let j = rowStart; j < rowEnd + 1; j++) {\n        const imageLine = imageLines[j];\n\n        if (imageLine === undefined) {\n          console.error(\"j:\", j);\n          console.error(\"imageLines:\", imageLines);\n          throw Error(\"imageLines\");\n        }\n\n        // because you know x is zero in ax + by = c, so by = c and b = -1, so -1 * y = c or y = -1 * c\n        const imageLineY = -1 * imageLine.c;\n\n        const startsOnLine = y1 === imageLineY;\n        const endsOnLine = y2 === imageLineY;\n        const endsOffLine = !endsOnLine;\n\n        let xminOnLine, xmaxOnLine;\n        if (horizontal) {\n          if (edgeY === imageLineY) {\n            xminOnLine = startLng;\n            xmaxOnLine = endLng;\n          } else {\n            continue; // stop running calculations for this horizontal line because it doesn't intersect at all\n          }\n        } else if (vertical) {\n          /* we have to have a seprate section for vertical because of floating point arithmetic probs with get_inter...\" */\n          if (imageLineY >= edgeYMin && imageLineY <= edgeYMax) {\n            xminOnLine = startLng;\n            xmaxOnLine = endLng;\n          }\n        } else if (startsOnLine) {\n          // we know that the other end is not on the line because then it would be horizontal\n          xminOnLine = xmaxOnLine = x1;\n        } else if (endsOnLine) {\n          // we know that the other end is not on the line because then it would be horizontal\n          xminOnLine = xmaxOnLine = x2;\n        } else {\n          try {\n            xminOnLine = xmaxOnLine = getIntersectionOfTwoLines(edgeLine, imageLine).x;\n          } catch (error) {\n            throw error;\n          }\n        }\n\n        // check to see if the intersection point is within the range of\n        // the edge line segment. If it is, add the intersection to the\n        // list of intersections at the corresponding index for that row\n        // in intersectionsByRow\n        if (xminOnLine && xmaxOnLine && (horizontal || (xminOnLine >= startLng && xmaxOnLine <= endLng && imageLineY <= edgeYMax && imageLineY >= edgeYMin))) {\n          intersectionsByRow[j].push({\n            direction,\n            index: i,\n            edge,\n            endsOnLine,\n            endsOffLine,\n            horizontal,\n            startsOnLine,\n            vertical,\n            xmin: xminOnLine,\n            xmax: xmaxOnLine,\n            imageLineY\n          });\n        }\n      }\n    }\n\n    intersectionsByRow.map((segmentsInRow, row_index) => {\n      if (segmentsInRow.length > 0) {\n        const clusters = clusterLineSegments(segmentsInRow, numberOfEdges);\n        const categorized = clusters.map(categorizeIntersection);\n        const [throughs, nonthroughs] = partition(categorized, item => item.through);\n\n        if (throughs.length % 2 === 1) {\n          throw Error(\"throughs.length for \" + row_index + \" is odd with \" + throughs.length);\n        }\n\n        let insides = nonthroughs.map(intersection => [intersection.xmin, intersection.xmax]);\n\n        // sorts throughs from left to right in-place\n        throughs.sort((a, b) => a.xmin - b.xmin);\n\n        const couples = couple(throughs).map(couple => {\n          const [left, right] = couple;\n          return [left.xmin, right.xmax];\n        });\n\n        insides = insides.concat(couples);\n\n        /*\n          This makes sure we don't double count pixels.\n          For example, converts `[[0,10],[10,10]]` to `[[0,10]]`\n        */\n        insides = mergeRanges(insides);\n\n        insides.forEach(pair => {\n          const [xmin, xmax] = pair;\n\n          //convert left and right to image pixels\n          const left = Math.round((xmin - (raster_xmin + 0.5 * pixel_width)) / pixel_width);\n          const right = Math.round((xmax - (raster_xmin + 0.5 * pixel_width)) / pixel_width);\n\n          // skip because segment is beyond the right edge of the raster\n          if (left >= raster_width) return;\n\n          // skip because segment is beyond the left edge of the raster\n          if (right < 0) return;\n\n          const start_column_index = Math.max(left, 0);\n          const end_column_index = Math.min(right, raster_width - 1);\n\n          if (per_row_segment) {\n            per_row_segment({\n              row: row_index,\n              columns: [start_column_index, end_column_index]\n            });\n          }\n\n          if (per_pixel) {\n            for (let column_index = start_column_index; column_index <= end_column_index; column_index++) {\n              per_pixel({ row: row_index, column: column_index });\n            }\n          }\n        });\n      }\n    });\n  });\n};\n","const calculateCallbacks = require(\"./calculate-core.js\");\nconst checkRows = require(\"./check-rows.js\");\nconst mergeConsecutiveRanges = require(\"./merge-consecutive-ranges.js\");\n\nmodule.exports = function calculate({\n  debug = false,\n  raster_bbox,\n  raster_height,\n  raster_width,\n  pixel_height,\n  pixel_width,\n  geometry,\n  per_pixel,\n  per_row_segment\n}) {\n  const [xmin, ymin, xmax, ymax] = raster_bbox;\n  pixel_height ??= (ymax - ymin) / raster_height;\n  pixel_width ??= (xmax - xmin) / raster_width;\n\n  const rows = new Array(raster_height);\n\n  calculateCallbacks({\n    raster_bbox,\n    raster_height,\n    raster_width,\n    pixel_height,\n    pixel_width,\n    geometry,\n    per_pixel,\n    per_row_segment: ({ row, columns }) => {\n      if (!rows[row]) rows[row] = [];\n      rows[row].push(columns);\n      if (per_row_segment) per_row_segment({ row, columns });\n    }\n  });\n\n  for (let irow = 0; irow < rows.length; irow++) {\n    const ranges = rows[irow];\n    if (ranges) {\n      // sort from left to right\n      ranges.sort((a, b) => (a === b ? a[1] - b[1] : a[0] - b[0]));\n\n      // replace existing row with sorted and merged one\n      rows[irow] = mergeConsecutiveRanges(ranges);\n    }\n  }\n\n  if (debug) checkRows(insides);\n\n  return { rows };\n};\n","module.exports = function categorizeIntersection(segments) {\n  try {\n    let through, xmin, xmax;\n\n    const n = segments.length;\n\n    const first = segments[0];\n\n    if (n === 1) {\n      through = true;\n      xmin = first.xmin;\n      xmax = first.xmax;\n    } /* n > 1 */ else {\n      const last = segments[n - 1];\n      through = first.direction === last.direction;\n      xmin = Math.min(first.xmin, last.xmin);\n      xmax = Math.max(first.xmax, last.xmax);\n    }\n\n    if (xmin === undefined || xmax === undefined || through === undefined || isNaN(xmin) || isNaN(xmax)) {\n      throw Error(\"categorizeIntersection failed with xmin\", xmin, \"and xmax\", xmax);\n    }\n\n    return { xmin, xmax, through };\n  } catch (error) {\n    console.error(\"[categorizeIntersection] segments:\", segments);\n    console.error(\"[categorizeIntersection]\", error);\n    throw error;\n  }\n};\n","module.exports = function checkRanges(rows) {\n  rows.forEach((ranges, irow) => {\n    for (let irange = 0; irange < ranges.length; irange++) {\n      const range = ranges[irange];\n      const [start, end] = range;\n      if (start > end) {\n        console.warn(\"[dufour-peyton-intersection] uh oh, encountered invalid range\", range, \"at row index\", irow, \"with ranges\", ranges);\n      }\n\n      for (let iother = irange + 1; iother < ranges.length; iother++) {\n        if (iother[0] <= end) {\n          console.warn(\"[dufour-peyton-intersection] encountered range problem on row index\", irow, \":\", ranges);\n        }\n      }\n    }\n  });\n};\n","module.exports = function clamp(n, min, max) {\n  if (n < min) return min;\n  else if (n > max) return max;\n  return n;\n};\n","const cluster = require(\"./cluster.js\");\n\nmodule.exports = function clusterLineSegments(lineSegments, numberOfEdges, debug = false) {\n  try {\n    const clusters = cluster(lineSegments, s => s.endsOffLine);\n\n    const numberOfClusters = clusters.length;\n\n    if (numberOfClusters >= 2) {\n      const firstCluster = clusters[0];\n      const firstSegment = firstCluster[0];\n      const lastCluster = clusters[clusters.length - 1];\n      const lastSegment = lastCluster[lastCluster.length - 1];\n\n      if (lastSegment.index === numberOfEdges - 1 && firstSegment.index === 0 && lastSegment.endsOnLine) {\n        clusters[0] = clusters.pop().concat(firstCluster);\n      }\n    }\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[clusterLineSegments]\", error);\n  }\n};\n","module.exports = function cluster(items, newClusterTest) {\n  try {\n    const numberOfItems = items.length;\n    const clusters = [];\n    let cluster = [];\n    for (let i = 0; i < numberOfItems; i++) {\n      const item = items[i];\n      cluster.push(item);\n      if (newClusterTest(item)) {\n        clusters.push(cluster);\n        cluster = [];\n      }\n    }\n\n    if (cluster.length > 0) clusters.push(cluster);\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[cluster]:\", error);\n  }\n};\n","// This function takes in an array with an even number of elements and\n// returns an array that couples every two consecutive elements;\nmodule.exports = function couple(array) {\n  const couples = [];\n  const lengthOfArray = array.length;\n  for (let i = 0; i < lengthOfArray; i += 2) {\n    couples.push([array[i], array[i + 1]]);\n  }\n  return couples;\n};\n","module.exports = function eachEdge(polygon, callback) {\n  polygon.forEach(ring => {\n    for (let i = 1; i < ring.length; i++) {\n      // should reuse previous endPoint as startPoint to save memory\n      const startPoint = ring[i - 1];\n      const endPoint = ring[i];\n      const edgeIndex = i - 1;\n      callback([startPoint, endPoint], edgeIndex);\n    }\n  });\n};\n","const getDepth = require(\"get-depth\");\n\n// call callback function for each polygon in geojson\nmodule.exports = function eachPolygon(geojson, callback) {\n  if (geojson.type === \"FeatureCollection\") {\n    geojson.features.forEach(feature => eachPolygon(feature, callback));\n  } else if (geojson.type === \"Feature\") {\n    eachPolygon(geojson.geometry, callback);\n  } else if (geojson.type === \"Polygon\") {\n    eachPolygon(geojson.coordinates, callback);\n  } else if (geojson.type === \"MultiPolygon\") {\n    geojson.coordinates.forEach(polygon => {\n      callback(polygon);\n    });\n  } else if (Array.isArray(geojson)) {\n    const depth = getDepth(geojson);\n    if (depth === 4) {\n      geojson.forEach(polygon => {\n        callback(polygon);\n      });\n    } else if (depth === 3) {\n      callback(geojson);\n    }\n  }\n};\n","const eachPolygon = require(\"./each-polygon.js\");\n\nmodule.exports = function getBoundingBox(geometry) {\n  let xmin, ymin, xmax, ymax;\n\n  eachPolygon(geometry, polygon => {\n    const ring = polygon[0]; // only want the exterior ring\n    const imax = ring.length - 1;\n\n    let i;\n    if (xmin === undefined) {\n      xmin = xmax = ring[0][0];\n      ymin = ymax = ring[0][1];\n      i = 1;\n    } else {\n      i = 0;\n    }\n\n    for (; i <= imax; i++) {\n      const [x, y] = ring[i];\n      if (x < xmin) xmin = x;\n      else if (x > xmax) xmax = x;\n      if (y < ymin) ymin = y;\n      else if (y > ymax) ymax = y;\n    }\n  });\n\n  return [xmin, ymin, xmax, ymax];\n};\n","const eachEdge = require(\"./each-edge.js\");\n\nmodule.exports = function getEdges(polygon) {\n  const edges = [];\n  eachEdge(polygon, edge => edges.push(edge));\n  return edges;\n};\n","// function to get the point at which two lines intersect\n// the input uses the line representations from the\n// getLineFromPoints function\nmodule.exports = function getIntersectionOfTwoLines(line1, line2) {\n  // calculate the determinant, ad - cb in a square matrix |a b|\n  const det = line1.a * line2.b - line2.a * line1.b; /*  |c d| */\n\n  if (det) {\n    // this makes sure the lines aren't parallel, if they are, det will equal 0\n    const x = (line2.b * line1.c - line1.b * line2.c) / det;\n    const y = (line1.a * line2.c - line2.a * line1.c) / det;\n    return { x, y };\n  }\n};\n","// function to convert two points into a\n// representation of a line\nmodule.exports = function getLineFromPoints(startPoint, endPoint) {\n  // get a, b, and c from line equation ax + by = c\n  const [x1, y1] = startPoint;\n  const [x2, y2] = endPoint;\n  const a = y2 - y1;\n  const b = x1 - x2;\n  const c = a * x1 + b * y1;\n\n  // return just a b and c since that is all we need\n  // to compute the intersection\n  return { a, b, c };\n};\n","const eachPolygon = require(\"./each-polygon.js\");\n\nmodule.exports = function getPolygons(geojson) {\n  const polygons = [];\n  eachPolygon(geojson, polygon => polygons.push(polygon));\n  return polygons;\n};\n","const categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst cluster = require(\"./cluster.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst calculate = require(\"./calculate.js\");\nconst calculateCore = require(\"./calculate-core.js\");\nconst couple = require(\"./couple.js\");\nconst getBoundingBox = require(\"./get-bounding-box.js\");\nconst getPolygons = require(\"./get-polygons.js\");\nconst eachEdge = require(\"./each-edge.js\");\nconst getIntersectionOfTwoLines = require(\"./get-intersection-of-two-lines.js\");\nconst getLineFromPoints = require(\"./get-line-from-points.js\");\nconst mergeRanges = require(\"./merge-ranges.js\");\nconst partition = require(\"./partition.js\");\nconst range = require(\"./range.js\");\n\nconst dufour_peyton_intersection = {\n  calculate,\n  calculateCore,\n  categorizeIntersection,\n  clamp,\n  cluster,\n  clusterLineSegments,\n  couple,\n  eachEdge,\n  getBoundingBox,\n  getIntersectionOfTwoLines,\n  getLineFromPoints,\n  getPolygons,\n  mergeRanges,\n  partition,\n  range\n};\n\nif (typeof define === \"function\" && define.amd) define(() => dufour_peyton_intersection);\nif (typeof module === \"object\") module.exports = dufour_peyton_intersection;\nif (typeof self == \"object\") self.dufour_peyton_intersection = dufour_peyton_intersection;\nif (typeof window == \"object\") window.dufour_peyton_intersection = dufour_peyton_intersection;\n","module.exports = function mergeConsecutiveRanges(ranges) {\n  const numberOfRanges = ranges.length;\n  if (numberOfRanges > 0) {\n    const firstRange = ranges[0];\n    let previousEnd = firstRange[1];\n    const result = [firstRange];\n    for (let i = 1; i < numberOfRanges; i++) {\n      const tempRange = ranges[i];\n      const [start, end] = tempRange;\n      if (start <= previousEnd + 1) {\n        result[result.length - 1][1] = end;\n      } else {\n        result.push(tempRange);\n      }\n      previousEnd = end;\n    }\n    return result;\n  }\n};\n","// This function takes in an array of number pairs and combines where there's overlap\nmodule.exports = function mergeRanges(ranges) {\n  const numberOfRanges = ranges.length;\n  if (numberOfRanges > 0) {\n    const firstRange = ranges[0];\n    let previousEnd = firstRange[1];\n    const result = [firstRange];\n    for (let i = 1; i < numberOfRanges; i++) {\n      const tempRange = ranges[i];\n      const [start, end] = tempRange;\n      if (start <= previousEnd) {\n        result[result.length - 1][1] = end;\n      } else {\n        result.push(tempRange);\n      }\n      previousEnd = end;\n    }\n    return result;\n  }\n};\n","module.exports = function partition(array, filter) {\n  const passed = [];\n  const unpassed = [];\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    const item = array[i];\n    if (filter(item)) passed.push(item);\n    else unpassed.push(item);\n  }\n  return [passed, unpassed];\n};\n","module.exports = function range(count) {\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) result[i] = i;\n  return result;\n};\n","const dufour_peyton_intersection = require(\"dufour-peyton-intersection\");\nconst subtract = require(\"preciso/subtract.js\");\nconst divide = require(\"preciso/divide.js\");\nconst reprojectGeoJSON = require(\"reproject-geojson/pluggable.js\");\nconst segflip = require(\"segflip\");\n\nfunction checkRows({ rows }) {\n  rows.forEach((segs, irow) => {\n    if (segs) {\n      segs.forEach(([start, end], iseg) => {\n        if (start > end) {\n          throw Error(`uh oh: invalid segment at row ${irow}, segment ${iseg}`);\n        }\n      });\n    }\n  });\n}\n\nfunction inside({\n  debug = false,\n  raster_bbox,\n  raster_height,\n  raster_width,\n  pixel_height,\n  pixel_width,\n  mask,\n  reproject\n}) {\n  if (typeof reproject === \"function\") {\n    // reproject geometry to the srs of the raster\n    mask = reprojectGeoJSON(mask, { in_place: false, reproject });\n  }\n\n  if (pixel_height === undefined)\n    pixel_height = Number(\n      divide(subtract(raster_bbox[3].toString(), raster_bbox[1].toString()), raster_height.toString())\n    );\n  if (pixel_width === undefined)\n    pixel_width = Number(\n      divide(subtract(raster_bbox[2].toString(), raster_bbox[0].toString()), raster_width.toString())\n    );\n\n  const { rows } = dufour_peyton_intersection.calculate({\n    raster_bbox,\n    raster_height,\n    raster_width,\n    pixel_height,\n    pixel_width,\n    geometry: mask\n  });\n\n  if (debug) checkRows({ rows });\n\n  return { rows };\n}\n\nfunction outside({\n  debug = false,\n  raster_bbox,\n  raster_height,\n  raster_width,\n  pixel_height,\n  pixel_width,\n  mask,\n  reproject\n}) {\n  if (typeof reproject === \"function\") {\n    // reproject geometry to the srs of the raster\n    mask = reprojectGeoJSON(mask, { in_place: false, reproject });\n  }\n\n  if (pixel_height === undefined)\n    pixel_height = Number(\n      divide(subtract(raster_bbox[3].toString(), raster_bbox[1].toString()), raster_height.toString())\n    );\n  if (pixel_width === undefined)\n    pixel_width = Number(\n      divide(subtract(raster_bbox[2].toString(), raster_bbox[0].toString()), raster_width.toString())\n    );\n\n  // calculate inside segments\n  const { rows: insides } = inside({\n    debug,\n    raster_bbox,\n    raster_height,\n    raster_width,\n    pixel_height,\n    pixel_width,\n    mask\n  });\n\n  if (debug) checkRows({ rows: insides });\n\n  const last_column_index = raster_width - 1;\n\n  // consider optimizing memory and speed\n  // by just returning a reference to a whole row\n  // instead of generating a new array every time\n  // const whole_row = [0, last_column_index];\n\n  const outsides = [];\n  // using for loop instead of map because\n  // map skips empty insides/rows\n  for (let i = 0; i < insides.length; i++) {\n    const segs = insides[i];\n    if (!Array.isArray(segs) || segs.length === 0) {\n      outsides.push([[0, last_column_index]]);\n    } else {\n      outsides.push(\n        segflip({\n          segments: segs,\n          min: 0,\n          max: last_column_index,\n          debug: false\n        })\n      );\n    }\n  }\n\n  if (debug) checkRows({ rows: outsides });\n\n  return { rows: outsides };\n}\n\nconst geomask = { inside, outside };\n\nif (typeof module === \"object\") module.exports = geomask;\n","module.exports = function getDepth(arr) {\n  const isArray = (arr) =>\n    Array.isArray(arr) ||\n    arr instanceof Int8Array ||\n    arr instanceof Uint8Array ||\n    arr instanceof Uint8ClampedArray ||\n    arr instanceof Int16Array ||\n    arr instanceof Uint16Array ||\n    arr instanceof Int32Array ||\n    arr instanceof Uint32Array ||\n    arr instanceof Float32Array ||\n    arr instanceof Float64Array ||\n    arr instanceof BigInt64Array ||\n    arr instanceof BigUint64Array;\n\n  let depth = 0;\n  let part = arr;\n  while (isArray(part)) {\n    depth++;\n    part = part[0];\n  }\n  return depth;\n};\n","const clean = require(\"./clean.js\");\nmodule.exports = function absolute(n) {\n  n = clean(n);\n  if (n[0] === \"-\") return n.substring(1);\n  else return n;\n};\n","const compare_positive = require(\"./compare_positive.js\");\nconst clean = require(\"./clean.js\");\nconst long_addition = require(\"./long_addition.js\");\nconst long_subtraction = require(\"./long_subtraction.js\");\n\nmodule.exports = function add(a, b) {\n  a = clean(a);\n  b = clean(b);\n\n  const apos = a[0] !== \"-\";\n  const bpos = b[0] !== \"-\";\n\n  if (apos && bpos) {\n    return long_addition(a, b);\n  } else if (!apos && !bpos) {\n    return \"-\" + long_addition(a.substring(1), b.substring(1));\n  } else if (!apos && bpos) {\n    a = a.substring(1);\n    switch (compare_positive(a, b)) {\n      case \"=\":\n        return \"0\";\n      case \"<\":\n        return long_subtraction(b, a);\n      case \">\":\n        return \"-\" + long_subtraction(a, b);\n    }\n  } else if (apos && !bpos) {\n    b = b.substring(1);\n    switch (compare_positive(a, b)) {\n      case \"=\":\n        return \"0\";\n      case \"<\":\n        return \"-\" + long_subtraction(b, a);\n      case \">\":\n        return long_subtraction(a, b);\n    }\n  }\n};\n","const expand = require(\"./expand.js\");\n\nmodule.exports = function clean(n) {\n  // remove + from beginning\n  if (n[0] === \"+\") n = n.substring(1);\n\n  n = expand(n);\n\n  // remove extra zero in front\n  // 03938.123 => 3938.123\n  n = n.replace(/^0+(?=\\d)/, \"\");\n\n  // remove extra zero at end\n\n  return n;\n};\n","const clean = require(\"./clean.js\");\n\n// given:\n//  - a and b are positive numbers\n//  - a and b have been cleaned (i.e. no + or leading zeros)\nmodule.exports = function compare_positive(a, b) {\n  const alen = a.length;\n  const blen = b.length;\n\n  const aidx = a.indexOf(\".\");\n  const bidx = b.indexOf(\".\");\n\n  // basically where would the dot be\n  // if we add a dot at the end of integers\n  // like 123.\n  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;\n  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;\n\n  // how much you need to shift the second number\n  // to line up the decimal with the first\n  //        0.12345\n  //    12345.0\n\n  const offset = a_adjusted_dot_index - b_adjusted_dot_index;\n\n  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);\n\n  let right = Math.max(alen - a_adjusted_dot_index, blen - b_adjusted_dot_index);\n\n  let aoffset = offset < 0 ? -1 * offset : 0;\n  let boffset = offset <= 0 ? 0 : offset;\n\n  let imax = left + 1 + right - 1; // -1 for zero-index\n\n  let i = 0;\n  while (i < imax) {\n    const achar = a[i - aoffset] || \"0\";\n    const bchar = b[i - boffset] || \"0\";\n    if (achar !== bchar) {\n      if (achar > bchar) return \">\";\n      else if (achar < bchar) return \"<\";\n    }\n    i++;\n  }\n\n  return \"=\";\n};\n","const absolute = require(\"./absolute.js\");\nconst clean = require(\"./clean.js\");\nconst long_division = require(\"./long_division.js\");\n\nmodule.exports = function (dividend, divisor, options) {\n  dividend = clean(dividend);\n  divisor = clean(divisor);\n\n  const dividend_is_positive = dividend[0] !== \"-\";\n  const divisor_is_positive = divisor[0] !== \"-\";\n\n  const out_sign = dividend_is_positive !== divisor_is_positive ? \"-\" : \"\";\n\n  if (!dividend_is_positive) dividend = absolute(dividend);\n  if (!divisor_is_positive) divisor = absolute(divisor);\n\n  return out_sign + long_division(dividend, divisor, options);\n};\n","// convert exponential notation to normal string\n// not optimized yet and no support for big numbers\nmodule.exports = function expand(n) {\n  // remove + from beginning\n  if (n[0] === \"+\") n = n.substring(1);\n\n  const sign = n[0] === \"-\" ? \"-\" : \"\";\n  if (sign === \"-\") n = n.substring(1);\n\n  const index_of_e = n.indexOf(\"e\");\n\n  // number not in exponential notation\n  if (index_of_e === -1) return sign + n;\n\n  let index_of_dot = n.indexOf(\".\");\n\n  // if number doesn't include a period dot\n  // then just assume it at the end\n  // such that 3e4 has index of dot at 1\n  if (index_of_dot === -1) index_of_dot = index_of_e;\n\n  const shift = Number(n.substring(index_of_e + 1));\n\n  // remove old decimal place\n  const base = n.substring(0, index_of_e).replace(\".\", \"\");\n\n  // normalize shift to start of the string at index zero\n  const normshift = index_of_dot + shift;\n\n  const baselen = base.length;\n\n  if (normshift >= baselen) {\n    const zct = normshift - baselen;\n    let result = base;\n    for (let i = 0; i < zct; i++) result += \"0\";\n    return sign + result;\n  } else if (normshift < 0) {\n    // need to add zeros in decimal places\n    result = \"0.\";\n    for (let i = 0; i > normshift; i--) result += \"0\";\n    result += base;\n    return sign + result;\n  } else {\n    // shifting within the base\n    return sign + base.substring(0, normshift) + \".\" + base.substring(normshift);\n  }\n};\n","// assumes both numbers are positive integers\nmodule.exports = function long_addition(a, b) {\n  // assuming both positive for now\n\n  const alen = a.length;\n  const blen = b.length;\n\n  const aidx = a.indexOf(\".\");\n  const bidx = b.indexOf(\".\");\n\n  // basically where would the dot be\n  // if we add a dot at the end of integers\n  // like 123.\n  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;\n  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;\n\n  // how much you need to shift the second number\n  // to line up the decimal with the first\n  //        0.12345\n  //    12345.0\n\n  const offset = a_adjusted_dot_index - b_adjusted_dot_index;\n\n  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);\n\n  let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);\n\n  let aoffset = offset < 0 ? -1 * offset : 0;\n  let boffset = offset <= 0 ? 0 : offset;\n\n  let imax = left + 1 + right - 1; // -1 for zero-index\n\n  let result = \"\";\n\n  let carried = 0;\n\n  // to the right of the period\n  //        0.12345\n  //    12345.0\n  let i = imax;\n  if (right > 0) {\n    while (i > imax - right) {\n      const achar = a[i - aoffset] || \"0\";\n      const bchar = b[i - boffset] || \"0\";\n      let n = Number(achar) + Number(bchar) + carried;\n      if (n >= 10) {\n        n -= 10;\n        carried = 1;\n      } else {\n        carried = 0;\n      }\n      if (result !== \"\" || n !== 0) {\n        result = n + result;\n      }\n      i--;\n    }\n    if (result) result = \".\" + result;\n    i--; // substract 1 for dot\n  }\n\n  if (left > 0) {\n    while (i >= 0) {\n      const achar = a[i - aoffset] || \"0\";\n      const bchar = b[i - boffset] || \"0\";\n      let n = Number(achar) + Number(bchar) + carried;\n      if (n >= 10) {\n        n -= 10;\n        carried = 1;\n      } else {\n        carried = 0;\n      }\n      result = n + result;\n      i--;\n    }\n  }\n\n  if (carried === 1) {\n    result = carried + result;\n  }\n\n  return result;\n};\n","const compare_positive = require(\"./compare_positive.js\");\nconst add = require(\"./add.js\");\nconst multiply = require(\"./multiply.js\");\nconst subtract = require(\"./subtract.js\");\nconst round_last_decimal = require(\"./round_last_decimal.js\");\n\n// given dividend and divisor are positive numberical strings\nmodule.exports = function long_division(dividend, divisor, { max_decimal_digits = 100, ellipsis = false } = {}) {\n  // remove unnecessary starting zeros\n  // ex: 0.5 => .5\n  if (dividend[0] === \"0\") dividend = dividend.substring(1);\n  if (divisor[0] === \"0\") divisor = divisor.substring(1);\n\n  const dividend_index_of_dot = dividend.indexOf(\".\");\n  const divisor_index_of_dot = divisor.indexOf(\".\");\n\n  const adjusted_dividend_index_of_dot = dividend_index_of_dot === -1 ? dividend.length : dividend_index_of_dot;\n  const divisor_num_decimal_places = divisor_index_of_dot === -1 ? 0 : divisor.length - 1 - divisor_index_of_dot;\n\n  // whether the result has a repeating decimal\n  // e.g. 1/3 is repeating as in \"0.333...\"\n  let repeating = false;\n\n  // remove decimals\n  dividend = dividend.replace(/\\./, \"\");\n  divisor = divisor.replace(/\\./, \"\");\n\n  const dividend_length = dividend.length;\n\n  let current = \"\";\n  let quotient = \"\";\n  let comparison;\n  let offset = -1 * divisor_num_decimal_places;\n  let skip = 0;\n  for (let i = 0; i < dividend_length; i++) {\n    const char = dividend[i];\n\n    current += char;\n\n    comparison = compare_positive(current, divisor);\n\n    if (comparison === \">\") {\n      // same as const times = Math.floor(current / divisor);\n      // but without floating point problems\n      let times = 1;\n      let product = add(divisor, divisor);\n      let passed_product = divisor;\n      while (compare_positive(product, current) !== \">\") {\n        times++;\n        passed_product = product;\n        product = add(product, divisor);\n      }\n      times = times.toString();\n\n      if (quotient !== \"\") {\n        for (let i = times.length; i <= skip; i++) quotient += \"0\";\n      }\n      quotient += times; // string concatentation\n\n      current = subtract(current, passed_product);\n\n      skip = 0;\n    } else if (comparison === \"<\") {\n      if (quotient === \"\") {\n        offset++;\n      }\n      skip++;\n\n      // outside greater than inside\n      continue;\n    } else if (comparison === \"=\") {\n      if (quotient !== \"\") {\n        for (let i = 0; i < skip; i++) quotient += \"0\";\n      }\n      quotient += \"1\";\n      current = \"0\";\n      skip = 0;\n    }\n  }\n\n  if (current.match(/^0+$/g)) {\n    if (comparison === \"<\") {\n      quotient += current.substring(0, current.length - 1);\n    }\n  } else {\n    const previous = {};\n\n    // keep dividing until we have an answer\n    // figure out current place of decimal number\n    const idot = adjusted_dividend_index_of_dot - offset;\n    const qlen = quotient.length;\n    // add 1 extra for rounding purposes\n    const imax = idot - qlen + max_decimal_digits + 1;\n\n    // reset skip if just \"\" so far because don't want to count 0 in 0.\n    if (quotient === \"\") {\n      skip = 0;\n    }\n\n    for (let i = 0; i < imax; i++) {\n      current += \"0\";\n      if (ellipsis) {\n        if (current in previous) {\n          previous[current]++;\n          if (previous[current] > 3) {\n            quotient += \"...\";\n            repeating = true;\n            break;\n          }\n        } else {\n          previous[current] = 1;\n        }\n      }\n      const comparison = compare_positive(current, divisor);\n\n      if (comparison === \">\") {\n        // inside greater than outside\n\n        // how many times the divisor goes into the current\n        let times = 1;\n        let product = add(divisor, divisor);\n        let passed_product = divisor;\n        while (compare_positive(product, current) !== \">\") {\n          times++;\n          passed_product = product;\n          product = add(product, divisor);\n        }\n\n        times = times.toString();\n\n        // pad left zeros\n        for (let i = times.length; i <= skip; i++) quotient += \"0\";\n        quotient += times; // string concatentation\n        current = subtract(current, passed_product);\n\n        if (current === \"0\") {\n          break;\n        }\n\n        skip = 0;\n      } else if (comparison === \"<\") {\n        // outside greater than inside\n        skip++;\n        continue;\n      } else if (comparison === \"=\") {\n        // fill in previous with zeros\n        for (let i = 0; i < skip; i++) quotient += \"0\";\n        quotient += \"1\";\n        skip = 0;\n        break;\n      }\n    }\n  }\n\n  // reinsert decimal place\n\n  const idot = adjusted_dividend_index_of_dot - offset;\n  const qlen = quotient.length;\n\n  let num_decimals;\n\n  if (idot === qlen) {\n    // integer number so don't do anything\n    num_decimals = 0;\n  } else if (idot < 0) {\n    quotient = \"0.\" + \"0\".repeat(Math.abs(idot)) + quotient;\n    num_decimals = qlen - idot; // idot is negative, so adding\n  } else if (idot > qlen) {\n    // add more zeros to integer\n    for (let i = qlen; i < idot; i++) quotient += \"0\";\n    num_decimals = 0;\n  } else if (idot < qlen) {\n    quotient = quotient.substring(0, idot) + \".\" + quotient.substring(idot);\n    num_decimals = qlen - idot;\n  } else if (idot === 0) {\n    quotient = \"0.\" + quotient;\n    num_decimals = qlen;\n  }\n\n  // remove zeros from front\n  // 03938.123 => 3938.123\n  quotient = quotient.replace(/^0+/, \"\");\n\n  // remove extra zeros from the end\n  quotient = quotient.replace(/\\.\\d+0+$/, \"\");\n\n  // round if necessary\n  if (!repeating) {\n    const extra_decimals = num_decimals - max_decimal_digits;\n    if (extra_decimals > 0) {\n      quotient = round_last_decimal(quotient.substring(0, quotient.length - extra_decimals + 1));\n    }\n  }\n\n  if (quotient[0] === \".\") quotient = \"0\" + quotient;\n\n  return quotient;\n};\n","const CHUNK_SIZE = 15;\n\n/**\n *\n * @param {String} a - numerical string larger or equal to b\n * @param {String} b - numerical string smaller or equal to a\n * @returns {String} product - result of multiplying a with b\n */\n\nmodule.exports = function long_multiplication(a, b) {\n  if (a === \"0\" || b === \"0\") return \"0\";\n\n  const top_index_of_dot = a.indexOf(\".\");\n  const bottom_index_of_dot = b.indexOf(\".\");\n\n  const a_num_decimal_places = top_index_of_dot === -1 ? 0 : a.length - 1 - top_index_of_dot;\n  const b_num_decimal_places = bottom_index_of_dot === -1 ? 0 : b.length - 1 - bottom_index_of_dot;\n\n  const out_num_decimal_places = a_num_decimal_places + b_num_decimal_places;\n\n  // remove decimals\n  a = a.replace(\".\", \"\");\n  b = b.replace(\".\", \"\");\n\n  const alen = a.length;\n  const blen = b.length;\n\n  const chunks = [];\n  let i = alen;\n  while (i >= 0) {\n    const end = i;\n    const start = (i -= CHUNK_SIZE);\n    const str = a.substring(start, end);\n    chunks.push([Number(str), str.length]);\n  }\n\n  const partial_products = [];\n  const partials = [];\n\n  // for each number in multiplier\n  for (let i = 0, ireverse = blen - 1; ireverse >= 0; ireverse--, i++) {\n    const bstr = b[ireverse];\n\n    const bnum = Number(bstr);\n\n    let carried = 0;\n    let partial = \"\";\n    const ichunklast = chunks.length - 1;\n    chunks.forEach(([chunk, chunklen], c) => {\n      const subpartial = carried + bnum * chunk;\n      let subpartstr = subpartial.toString();\n      const subpartcharlen = subpartstr.length;\n      if (subpartcharlen > chunklen && c !== ichunklast) {\n        const islice = -1 * chunklen;\n        partial = subpartstr.slice(islice) + partial;\n        carried = Number(subpartstr.slice(0, islice));\n      } else {\n        const imax = chunklen - subpartcharlen;\n        for (let i = 0; i < imax; i++) {\n          subpartstr = \"0\" + subpartstr;\n        }\n        carried = 0;\n        partial = subpartstr + partial;\n      }\n    });\n\n    // add number of zeros at end\n    partial += \"0\".repeat(i);\n\n    partial_products.push(partial);\n\n    partials.push([Array.from(partial).map(char => Number(char)), partial.length]);\n  }\n\n  // back to front, iterate through columns\n  // and add partial products together\n  const num_partials = partial_products.length;\n\n  const number_of_columns = partials[partials.length - 1][1] + num_partials;\n\n  let result = \"\";\n  let carried = 0;\n  for (let icol = 0; icol < number_of_columns; icol++) {\n    let sum = carried;\n    const pmax = Math.min(icol, num_partials - 1);\n    for (let p = 0; p <= pmax; p++) {\n      const [pnums, plen] = partials[p];\n      const i = plen - 1 - icol;\n      if (i >= 0) {\n        sum += pnums[i];\n      }\n    }\n\n    if (sum >= 10) {\n      sum = sum.toString();\n      result = sum[sum.length - 1] + result;\n      carried = Number(sum.slice(0, -1));\n    } else {\n      result = sum + result;\n      carried = 0;\n    }\n  }\n\n  // add decimal back in\n  if (out_num_decimal_places === 0) {\n    // integer\n    // remove extra zeros\n    result = result.replace(/^0+/, \"\");\n  } else {\n    // decimal number\n    const idot = result.length - out_num_decimal_places;\n\n    result = result.substring(0, idot) + \".\" + result.substring(idot);\n\n    // remove zeros from front\n    result = result.replace(/^0+/, \"\");\n\n    // remove extra zeros from the end\n    result = result.replace(/\\.?0+$/, \"\");\n\n    if (result[0] === \".\") result = \"0\" + result;\n  }\n\n  return result;\n};\n","// const lookup = {};\n// const vals = [undefined, 0, 1, 2, 3, 4, 5, 6, 8, 9];\n// vals.forEach(top => {\n//   lookup[top] = {};\n//   vals.forEach(bottom => {\n//     lookup[top][bottom] = (top || 0) - (bottom || 0);\n//   })\n// });\n\n// assumes (1) both a and b are positive numbers\n// and (2) a is larger than b\nmodule.exports = function long_subtraction(a, b) {\n  const alen = a.length;\n  const blen = b.length;\n\n  const aidx = a.indexOf(\".\");\n  const bidx = b.indexOf(\".\");\n\n  // basically where would the dot be\n  // if we add a dot at the end of integers\n  // like 123.\n  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;\n  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;\n  // console.log({a_adjusted_dot_index, b_adjusted_dot_index});\n\n  // how much you need to shift the second number\n  // to line up the decimal with the first\n  //        0.12345\n  //    12345.0\n\n  const offset = a_adjusted_dot_index - b_adjusted_dot_index;\n  // console.log(\"offset:\", offset);\n\n  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);\n  // console.log(\"left:\", left);\n\n  let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);\n  // console.log(\"right:\", right);\n\n  let aoffset = offset < 0 ? -1 * offset : 0;\n  let boffset = offset <= 0 ? 0 : offset;\n  // console.log({aoffset, boffset});\n\n  let imax = left + 1 + right - 1; // -1 for zero-index\n  // console.log({imax});\n\n  let result = \"\";\n\n  // number of borrowings\n  let borrowed = 0;\n\n  // to the right of the period\n  //  100.5  6  7\n  //    2.2  9  3\n  //        (-3 + 10)  4\n  let i = imax;\n  if (right > 0) {\n    while (i > imax - right) {\n      // console.log(\"\\n\\n\", {i});\n      let top = a[i - aoffset] || \"0\";\n      let bottom = b[i - boffset] || \"0\";\n\n      // console.log(\"pre borrowing\", {top, bottom});\n      top -= borrowed;\n      borrowed = 0;\n\n      // console.log(\"after borrowing\", {top, bottom});\n      let n = top - bottom;\n\n      // console.log({n});\n      if (n < 0) {\n        while (n < 0) {\n          borrowed++;\n          n += 10;\n        }\n      } else if (borrowed) {\n        borrowed--;\n      }\n      // console.log({n});\n      if (result !== \"\" || n !== 0) {\n        result = n + result;\n      }\n      i--;\n    }\n    if (result !== \"\") {\n      result = \".\" + result;\n    }\n    i--; // substract 1 for dot\n  }\n\n  // console.log({result});\n\n  if (left > 0) {\n    while (i > 0) {\n      // console.log(\"\\n\\n\", {i});\n      let top = a[i - aoffset] || \"0\";\n      let bottom = b[i - boffset] || \"0\";\n\n      // console.log(\"pre borrowing\", {top, bottom});\n      top -= borrowed;\n      borrowed = 0;\n\n      // console.log(\"after borrowing\", {top, bottom});\n      let n = top - bottom;\n\n      // console.log({n});\n      if (n < 0) {\n        while (n < 0) {\n          borrowed++;\n          n += 10;\n        }\n      } else if (borrowed) {\n        borrowed--;\n      }\n      // console.log({n});\n      result = n + result;\n      i--;\n    }\n\n    // console.log({borrowed});\n    // special rule for last one\n    const achar = a[0 - aoffset] || \"0\";\n    const bchar = b[0 - boffset] || \"0\";\n    let n = Number(achar) - (borrowed > 0 ? 1 : 0) - Number(bchar);\n    if (n !== 0) {\n      result = n + result;\n    }\n\n    // remove any zeros in front like in 0123\n    result = result.replace(/^0+/, \"\");\n  }\n\n  // if decimal number add zero\n  if (result[0] === \".\") result = \"0\" + result;\n\n  return result;\n};\n","const absolute = require(\"./absolute.js\");\nconst clean = require(\"./clean.js\");\nconst compare_positive = require(\"./compare_positive.js\");\nconst long_multiplication = require(\"./long_multiplication.js\");\n\nmodule.exports = function multiply(a, b) {\n  a = clean(a);\n  b = clean(b);\n\n  const apos = a[0] !== \"-\";\n  const bpos = b[0] !== \"-\";\n\n  const out_sign = apos !== bpos ? \"-\" : \"\";\n\n  a = absolute(a);\n  b = absolute(b);\n\n  const comparison = compare_positive(a, b);\n\n  if (comparison === \"<\") {\n    const aold = a;\n    const bold = b;\n    a = bold;\n    b = aold;\n  }\n\n  return out_sign + long_multiplication(a, b);\n};\n","// given n is a decimal number\nconst up = [\"5\", \"6\", \"7\", \"8\", \"9\"];\nmodule.exports = function round_last_decimal(n) {\n  // remove + from beginning\n  if (n[0] === \"+\") n = n.substring(1);\n\n  //console.log(\"rounding:\", {n});\n  const len = n.length;\n  //console.log({len});\n  let result = \"\";\n\n  const last_char = n[n.length - 1];\n  //console.log({last_char});\n\n  if (up.includes(last_char)) {\n    let i;\n    for (i = len - 2; i >= 0; i--) {\n      const char = n[i];\n      //console.log({char});\n      // skip over . or -\n      if (char === \".\" || char === \"-\") continue;\n\n      const nchar = Number(char) + 1;\n      //console.log({nchar});\n\n      if (nchar === 10) {\n        result = \"0\" + result;\n        // keep rounding up\n      } else {\n        result = nchar + result;\n        break;\n      }\n    }\n    //console.log({i});\n    if (i > 0) result = n.substring(0, i) + result;\n  } else {\n    result = n.substring(0, len - 1);\n  }\n\n  if (result[result.length - 1] === \".\") result = result.substring(0, result.length - 1);\n\n  // remove trailing zeros in decimal number\n  // 0.50 => 0.5\n  if (result.indexOf(\".\") > -1) result = result.replace(/0+$/, \"\");\n\n  return result;\n};\n","const clean = require(\"./clean\");\nconst compare_positive = require(\"./compare_positive.js\");\nconst long_addition = require(\"./long_addition.js\");\nconst long_subtraction = require(\"./long_subtraction.js\");\n\nmodule.exports = function subtract(a, b) {\n  a = clean(a);\n  b = clean(b);\n\n  const a_is_positive = a[0] !== \"-\";\n  const b_is_positive = b[0] !== \"-\";\n  if (a_is_positive) {\n    if (b_is_positive) {\n      const comparison = compare_positive(a, b);\n      if (comparison === \">\") {\n        return long_subtraction(a, b);\n      } else if (comparison === \"<\") {\n        return \"-\" + long_subtraction(b, a);\n      } else {\n        return \"0\";\n      }\n    } else {\n      return long_addition(a, b.substring(1));\n    }\n  } else if (b_is_positive) {\n    return \"-\" + long_addition(a.substring(1), b);\n  } else {\n    a = a.substring(1);\n    b = b.substring(1);\n    const comparison = compare_positive(a, b);\n    if (comparison === \">\") {\n      return \"-\" + long_subtraction(a, b);\n    } else if (comparison === \"<\") {\n      return long_subtraction(b, a);\n    } else {\n      return \"0\";\n    }\n  }\n};\n","const clone = data => JSON.parse(JSON.stringify(data));\n\nfunction reprojectGeoJSONPluggable(data, { in_place = false, reproject }) {\n  if (typeof reproject !== \"function\") {\n    throw new Error(`[reproject-geojson] you must specify a reproject function`);\n  }\n  if (in_place !== true) data = clone(data);\n\n  if (data.type === \"FeatureCollection\") {\n    data.features = data.features.map(feature => reprojectGeoJSONPluggable(feature, { in_place, reproject }));\n  } else if (data.type === \"Feature\") {\n    data.geometry = reprojectGeoJSONPluggable(data.geometry, { in_place, reproject });\n  } else if (data.type === \"LineString\") {\n    data.coordinates = data.coordinates.map(coord => reproject(coord));\n  } else if (data.type === \"MultiLineString\") {\n    data.coordinates = data.coordinates.map(line => line.map(coord => reproject(coord)));\n  } else if (data.type === \"MultiPoint\") {\n    data.coordinates = data.coordinates.map(point => reproject(point));\n  } else if (data.type === \"MultiPolygon\") {\n    data.coordinates = data.coordinates.map(polygon => {\n      return polygon.map(ring => ring.map(coord => reproject(coord)));\n    });\n  } else if (data.type === \"Point\") {\n    data.coordinates = reproject(data.coordinates);\n  } else if (data.type === \"Polygon\") {\n    data.coordinates = data.coordinates.map(ring => ring.map(coord => reproject(coord)));\n  }\n  return data;\n}\n\nif (typeof define === \"function\" && define.amd)\n  define(function () {\n    return reprojectGeoJSONPluggable;\n  });\nif (typeof module === \"object\") module.exports = reprojectGeoJSONPluggable;\nif (typeof window === \"object\") window.reprojectGeoJSONPluggable = reprojectGeoJSONPluggable;\nif (typeof self === \"object\") self.reprojectGeoJSONPluggable = reprojectGeoJSONPluggable;\n","// [ [0, 11], [58, 59] ],\n// [ [-1, 12], [57, 60] ] // subtract one from start and add one to end\n// [ 0, -1, 12, 57, 60, 255 ] // flatten\n// [ [0, -1], [12, 57], [60, 255] ] // pair\n// [ [12, 57], [60, 255] ] // discard bad like [0, -1]\n\nfunction segflip({ segments: segs, min = -Infinity, max = Infinity, debug = false }) {\n  if (debug) console.log(\"[segflip] segs:\", segs);\n  if (segs === undefined || segs === null || (Array.isArray(segs) && segs.length === 0)) {\n    if (debug) console.log(\"[segflip] segments are empty so return the whole row flipped\");\n    return [[min, max]];\n  }\n\n  const nums = segs.map(([start, end]) => [start - 1, end + 1]).flat();\n  nums.unshift(min);\n  nums.push(max);\n\n  if (debug) console.log(\"flattened nums:\", nums);\n\n  const results = [];\n  for (let i = 1; i < nums.length; i += 2) {\n    const start = nums[i - 1];\n    const end = nums[i];\n    if (start > end) continue; // e.g. [0, -1]\n    results.push([start, end]);\n  }\n  return results;\n}\n\nif (typeof define === \"function\" && define.amd)\n  define(function () {\n    return segflip;\n  });\nif (typeof module === \"object\") module.exports = segflip;\nif (typeof window === \"object\") window.segflip = segflip;\nif (typeof self === \"object\") self.segflip = segflip;\n","// takes in image data array and sets alpha value to 0 for parts outside the mask geometry\nfunction maskImageData({\n  data,\n  data_bbox,\n  data_height,\n  data_width,\n  data_srs,\n  debug = false,\n  geomask,\n  mask,\n  mask_srs,\n  reproject,\n  strategy = \"outside\",\n  edition\n}) {\n  if (![\"inside\", \"outside\"].includes(strategy)) {\n    throw new Error(`[geocanvas] strategy can be either \"inside\" or \"outside\". you provided \"${strategy}\"`);\n  }\n  const { rows } = geomask[strategy]({\n    raster_bbox: data_bbox,\n    raster_height: data_height,\n    raster_width: data_width,\n    raster_srs: data_srs,\n    mask,\n    mask_srs,\n    reproject\n  });\n\n  rows.forEach((ranges, r) => {\n    if (ranges) {\n      const row_offset = r * 4 * data_width;\n      ranges.forEach(([start, end]) => {\n        for (let c = start; c <= end; c++) {\n          data[row_offset + c * 4 + 3] = 0; // set alpha to zero\n        }\n      });\n    }\n  });\n}\n\nfunction maskCanvas({\n  canvas,\n  canvas_bbox,\n  canvas_srs,\n  geomask,\n  mask,\n  mask_srs,\n  reproject,\n  strategy = \"outside\",\n  edition,\n  debug = false\n}) {\n  if (debug) console.log(\"[geocanvas] starting to mask canvas\");\n  if (![\"inside\", \"outside\"].includes(strategy)) {\n    throw new Error(`[geocanvas] strategy can be either \"inside\" or \"outside\". you provided \"${strategy}\"`);\n  }\n  const context = canvas.getContext(\"2d\");\n  const { height, width } = canvas;\n  if (debug) console.log(`[geocanvas] canvas height is ${height} pixels`);\n  if (debug) console.log(`[geocanvas] canvas width is ${width} pixels`);\n  const imageData = context.getImageData(0, 0, width, height);\n  maskImageData({\n    data: imageData.data,\n    data_bbox: canvas_bbox,\n    data_height: height,\n    data_srs: canvas_srs,\n    data_width: width,\n    debug,\n    geomask,\n    mask,\n    mask_srs,\n    reproject,\n    strategy\n  });\n  if (debug) console.log(\"[geocanvas] image data after masking:\", imageData);\n  context.putImageData(imageData, 0, 0);\n  if (debug) console.log(\"[geocanvas] put image data back\");\n  return canvas;\n}\n\nmodule.exports = { maskImageData, maskCanvas };\n","const geomask = require(\"geomask/lite\");\nconst core = require(\"./core.js\");\n\n// basically have to provide everything you do in core except geomask\nfunction maskImageData(options) {\n  return core.maskImageData({ ...options, edition: \"lite\", geomask });\n}\n\nfunction maskCanvas(options) {\n  return core.maskCanvas({ ...options, edition: \"lite\", geomask });\n}\n\nconst geocanvas = { maskImageData, maskCanvas };\n\nif (typeof define === \"function\" && define.amd)\n  define(function () {\n    return geocanvas;\n  });\nif (typeof module === \"object\") module.exports = geocanvas;\nif (typeof self === \"object\") self.geocanvas = geocanvas;\nif (typeof window === \"object\") window.geocanvas = geocanvas;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(317);\n"],"names":["getLineFromPoints","categorizeIntersection","clamp","couple","clusterLineSegments","getEdges","getIntersectionOfTwoLines","getPolygons","mergeRanges","partition","range","module","exports","raster_bbox","raster_height","raster_width","pixel_height","pixel_width","geometry","per_pixel","per_row_segment","raster_xmin","raster_ymin","raster_xmax","raster_ymax","imageLines","y","lat","line","push","map","forEach","edges","intersectionsByRow","numberOfEdges","length","i","edge","startPoint","endPoint","x1","y1","x2","y2","direction","Math","sign","horizontal","vertical","edgeY","edgeLine","edgeYMin","min","edgeYMax","max","startLng","startLat","endLat","endLng","undefined","Error","imageY1","round","imageY2","rowStart","rowEnd","j","imageLine","console","error","imageLineY","c","startsOnLine","endsOnLine","endsOffLine","xminOnLine","xmaxOnLine","x","index","xmin","xmax","segmentsInRow","row_index","categorized","throughs","nonthroughs","item","through","insides","intersection","sort","a","b","couples","left","right","concat","pair","start_column_index","end_column_index","row","columns","column_index","column","calculateCallbacks","checkRows","mergeConsecutiveRanges","debug","ymin","ymax","rows","Array","irow","ranges","segments","n","first","last","isNaN","irange","start","end","warn","iother","cluster","lineSegments","clusters","s","firstCluster","firstSegment","lastCluster","lastSegment","pop","items","newClusterTest","numberOfItems","array","lengthOfArray","polygon","callback","ring","getDepth","eachPolygon","geojson","type","features","feature","coordinates","isArray","depth","imax","eachEdge","line1","line2","det","polygons","calculate","calculateCore","getBoundingBox","dufour_peyton_intersection","self","window","numberOfRanges","firstRange","previousEnd","result","tempRange","filter","passed","unpassed","len","count","subtract","divide","reprojectGeoJSON","segflip","segs","iseg","inside","mask","reproject","in_place","Number","toString","geomask","outside","last_column_index","outsides","arr","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","part","clean","substring","compare_positive","long_addition","long_subtraction","apos","bpos","expand","replace","alen","blen","aidx","indexOf","bidx","a_adjusted_dot_index","b_adjusted_dot_index","offset","aoffset","boffset","achar","bchar","absolute","long_division","dividend","divisor","options","dividend_is_positive","divisor_is_positive","out_sign","index_of_e","index_of_dot","shift","base","normshift","baselen","zct","carried","add","round_last_decimal","max_decimal_digits","ellipsis","dividend_index_of_dot","divisor_index_of_dot","adjusted_dividend_index_of_dot","divisor_num_decimal_places","repeating","dividend_length","comparison","current","quotient","skip","times","product","passed_product","match","previous","idot","qlen","num_decimals","repeat","abs","extra_decimals","top_index_of_dot","bottom_index_of_dot","out_num_decimal_places","chunks","str","partial_products","partials","ireverse","bstr","bnum","partial","ichunklast","chunk","chunklen","subpartstr","subpartcharlen","islice","slice","from","char","num_partials","number_of_columns","icol","sum","pmax","p","pnums","plen","borrowed","top","bottom","long_multiplication","aold","up","last_char","includes","nchar","a_is_positive","b_is_positive","reprojectGeoJSONPluggable","data","clone","coord","point","Infinity","log","nums","flat","unshift","results","maskImageData","data_bbox","data_height","data_width","data_srs","mask_srs","strategy","edition","raster_srs","r","row_offset","maskCanvas","canvas","canvas_bbox","canvas_srs","context","getContext","height","width","imageData","getImageData","putImageData","core","geocanvas","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}
{"version":3,"file":"dufour-peyton-intersection.min.js","mappings":"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","sources":["webpack://dufour-peyton-intersection/./node_modules/.pnpm/get-depth@0.0.3/node_modules/get-depth/index.js","webpack://dufour-peyton-intersection/./src/calculate-core.js","webpack://dufour-peyton-intersection/./src/calculate.js","webpack://dufour-peyton-intersection/./src/categorize-intersection.js","webpack://dufour-peyton-intersection/./src/check-rows.js","webpack://dufour-peyton-intersection/./src/clamp.js","webpack://dufour-peyton-intersection/./src/cluster-line-segments.js","webpack://dufour-peyton-intersection/./src/cluster.js","webpack://dufour-peyton-intersection/./src/couple.js","webpack://dufour-peyton-intersection/./src/each-edge.js","webpack://dufour-peyton-intersection/./src/each-polygon.js","webpack://dufour-peyton-intersection/./src/get-bounding-box.js","webpack://dufour-peyton-intersection/./src/get-edges.js","webpack://dufour-peyton-intersection/./src/get-intersection-of-two-lines.js","webpack://dufour-peyton-intersection/./src/get-line-from-points.js","webpack://dufour-peyton-intersection/./src/get-polygons.js","webpack://dufour-peyton-intersection/./src/index.js","webpack://dufour-peyton-intersection/./src/merge-consecutive-ranges.js","webpack://dufour-peyton-intersection/./src/merge-ranges.js","webpack://dufour-peyton-intersection/./src/partition.js","webpack://dufour-peyton-intersection/./src/prepare-snap.js","webpack://dufour-peyton-intersection/./src/range.js","webpack://dufour-peyton-intersection/./src/round-down.js","webpack://dufour-peyton-intersection/webpack/bootstrap","webpack://dufour-peyton-intersection/webpack/startup"],"sourcesContent":["module.exports = function getDepth(arr) {\n  const isArray = (arr) =>\n    Array.isArray(arr) ||\n    arr instanceof Int8Array ||\n    arr instanceof Uint8Array ||\n    arr instanceof Uint8ClampedArray ||\n    arr instanceof Int16Array ||\n    arr instanceof Uint16Array ||\n    arr instanceof Int32Array ||\n    arr instanceof Uint32Array ||\n    arr instanceof Float32Array ||\n    arr instanceof Float64Array ||\n    arr instanceof BigInt64Array ||\n    arr instanceof BigUint64Array;\n\n  let depth = 0;\n  let part = arr;\n  while (isArray(part)) {\n    depth++;\n    part = part[0];\n  }\n  return depth;\n};\n","const getLineFromPoints = require(\"./get-line-from-points.js\");\nconst categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst couple = require(\"./couple.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst getEdges = require(\"./get-edges.js\");\nconst getIntersectionOfTwoLines = require(\"./get-intersection-of-two-lines.js\");\nconst getPolygons = require(\"./get-polygons.js\");\nconst mergeRanges = require(\"./merge-ranges.js\");\nconst partition = require(\"./partition.js\");\nconst prepareSnap = require(\"./prepare-snap.js\");\nconst range = require(\"./range.js\");\n\nmodule.exports = function calculateCore({\n  debug_level = 0,\n  raster_bbox,\n  raster_height, // number of rows of pixels in the raster\n  raster_width, // number of columns of pixels in the raster\n  pixel_height,\n  pixel_width,\n  geometry,\n  per_pixel,\n  per_row_segment\n}) {\n  const [raster_xmin, raster_ymin, raster_xmax, raster_ymax] = raster_bbox;\n\n  // iterate through image rows and convert each one to a line\n  // running through the middle of the row\n  const imageLines = [];\n\n  if (raster_height === 0) return;\n\n  for (let y = 0; y < raster_height; y++) {\n    const lat = raster_ymax - pixel_height * y - pixel_height / 2;\n\n    // use that point, plus another point along the same latitude to\n    // create a line\n    const point0 = [raster_xmin, lat];\n    const point1 = [raster_xmin + 1, lat];\n    const line = getLineFromPoints(point0, point1);\n    imageLines.push(line);\n  }\n  if (debug_level >= 2) console.log(\"[dufour-peyton-intersection] imageLines:\", imageLines);\n\n  // collapse geometry down to a list of edges\n  // necessary for multi-part geometries\n  const polygons = getPolygons(geometry);\n  const polygonEdges = polygons.map(getEdges);\n\n  polygonEdges.forEach(edges => {\n    // iterate through the list of polygon vertices, convert them to\n    // lines, and compute the intersections with each image row\n    const intersectionsByRow = range(raster_height).map(() => []);\n    const numberOfEdges = edges.length;\n    for (let i = 0; i < numberOfEdges; i++) {\n      // get vertices that make up an edge and convert that to a line\n      const edge = edges[i];\n\n      const [startPoint, endPoint] = edge;\n      const [x1, y1] = startPoint;\n      const [x2, y2] = endPoint;\n\n      const direction = Math.sign(y2 - y1);\n      const horizontal = y1 === y2;\n      const vertical = x1 === x2;\n\n      const edgeY = y1;\n\n      const edgeLine = getLineFromPoints(startPoint, endPoint);\n\n      const edgeYMin = Math.min(y1, y2);\n      const edgeYMax = Math.max(y1, y2);\n\n      let startLng, startLat, endLat, endLng;\n      if (x1 < x2) {\n        [startLng, startLat] = startPoint;\n        [endLng, endLat] = endPoint;\n      } else {\n        [startLng, startLat] = endPoint;\n        [endLng, endLat] = startPoint;\n      }\n\n      if (startLng === undefined) throw Error(\"startLng is \" + startLng);\n\n      // find the y values in the image coordinate space\n      const imageY1 = Math.round((raster_bbox[3] - 0.5 * pixel_height - startLat) / pixel_height);\n      const imageY2 = Math.round((raster_bbox[3] - 0.5 * pixel_height - endLat) / pixel_height);\n\n      // make sure to set the start and end points so that we are\n      // incrementing upwards through rows\n      let rowStart, rowEnd;\n      if (imageY1 < imageY2) {\n        rowStart = imageY1;\n        rowEnd = imageY2;\n      } else {\n        rowStart = imageY2;\n        rowEnd = imageY1;\n      }\n\n      rowStart = clamp(rowStart, 0, raster_height - 1);\n      rowEnd = clamp(rowEnd, 0, raster_height - 1);\n      // iterate through image lines within the change in y of\n      // the edge line and find all intersections\n      for (let j = rowStart; j < rowEnd + 1; j++) {\n        const imageLine = imageLines[j];\n\n        if (imageLine === undefined) {\n          console.error(\"j:\", j);\n          console.error(\"imageLines:\", imageLines);\n          throw Error(\"imageLines\");\n        }\n\n        // because you know x is zero in ax + by = c, so by = c and b = -1, so -1 * y = c or y = -1 * c\n        const imageLineY = -1 * imageLine.c;\n\n        const startsOnLine = y1 === imageLineY;\n        const endsOnLine = y2 === imageLineY;\n        const endsOffLine = !endsOnLine;\n\n        let xminOnLine, xmaxOnLine;\n        if (horizontal) {\n          if (edgeY === imageLineY) {\n            xminOnLine = startLng;\n            xmaxOnLine = endLng;\n          } else {\n            continue; // stop running calculations for this horizontal line because it doesn't intersect at all\n          }\n        } else if (vertical) {\n          /* we have to have a seprate section for vertical because of floating point arithmetic probs with get_inter...\" */\n          if (imageLineY >= edgeYMin && imageLineY <= edgeYMax) {\n            xminOnLine = startLng;\n            xmaxOnLine = endLng;\n          }\n        } else if (startsOnLine) {\n          // we know that the other end is not on the line because then it would be horizontal\n          xminOnLine = xmaxOnLine = x1;\n        } else if (endsOnLine) {\n          // we know that the other end is not on the line because then it would be horizontal\n          xminOnLine = xmaxOnLine = x2;\n        } else {\n          try {\n            xminOnLine = xmaxOnLine = getIntersectionOfTwoLines(edgeLine, imageLine).x;\n          } catch (error) {\n            throw error;\n          }\n        }\n\n        // check to see if the intersection point is within the range of\n        // the edge line segment. If it is, add the intersection to the\n        // list of intersections at the corresponding index for that row\n        // in intersectionsByRow\n        if (\n          xminOnLine !== undefined &&\n          xmaxOnLine !== undefined &&\n          (horizontal || (xminOnLine >= startLng && xmaxOnLine <= endLng && imageLineY <= edgeYMax && imageLineY >= edgeYMin))\n        ) {\n          intersectionsByRow[j].push({\n            direction,\n            index: i,\n            edge,\n            endsOnLine,\n            endsOffLine,\n            horizontal,\n            startsOnLine,\n            vertical,\n            xmin: xminOnLine,\n            xmax: xmaxOnLine,\n            imageLineY\n          });\n        }\n      }\n    }\n\n    const half_pixel_width = pixel_width / 2;\n    const snap = prepareSnap(raster_xmin, pixel_width);\n\n    intersectionsByRow.forEach((segmentsInRow, row_index) => {\n      if (segmentsInRow.length > 0) {\n        const clusters = clusterLineSegments(segmentsInRow, numberOfEdges);\n        const categorized = clusters.map(categorizeIntersection);\n        const [throughs, nonthroughs] = partition(categorized, item => item.through);\n\n        if (throughs.length % 2 === 1) {\n          if (debug_level >= 1) console.error(\"throughs:\", JSON.stringify(throughs));\n          throw Error(\"throughs.length for \" + row_index + \" is odd with \" + throughs.length);\n        }\n\n        let insides = nonthroughs.map(intersection => [intersection.xmin, intersection.xmax]);\n\n        // sorts throughs from left to right in-place\n        throughs.sort((a, b) => a.xmin - b.xmin);\n\n        const couples = couple(throughs).map(couple => {\n          const [left, right] = couple;\n          return [left.xmin, right.xmax];\n        });\n\n        insides = insides.concat(couples);\n\n        /*\n          This makes sure we don't double count pixels.\n          For example, converts `[[0,10],[10,10]]` to `[[0,10]]`\n        */\n        insides = mergeRanges(insides);\n\n        insides.forEach(pair => {\n          const [xmin, xmax] = pair;\n\n          if (xmax - xmin < half_pixel_width) return;\n\n          // snap [xmin, xmax] in srs to raster coordinates\n          const [left, right] = snap(pair);\n\n          // intersection doesn't take up more than half of a pixel\n          if (left === right) return;\n\n          // skip because segment is beyond the right edge of the raster\n          if (left > raster_width) return;\n\n          // skip because segment is beyond the left edge of the raster\n          if (right <= 0) return;\n\n          const start_column_index = Math.max(left, 0);\n          const end_column_index = Math.min(right - 1, raster_width - 1);\n\n          if (per_row_segment) {\n            per_row_segment({\n              row: row_index,\n              columns: [start_column_index, end_column_index]\n            });\n          }\n\n          if (per_pixel) {\n            for (let column_index = start_column_index; column_index <= end_column_index; column_index++) {\n              per_pixel({ row: row_index, column: column_index });\n            }\n          }\n        });\n      }\n    });\n  });\n};\n","const calculateCallbacks = require(\"./calculate-core.js\");\nconst checkRows = require(\"./check-rows.js\");\nconst mergeConsecutiveRanges = require(\"./merge-consecutive-ranges.js\");\n\nmodule.exports = function calculate({\n  debug = false,\n  raster_bbox,\n  raster_height,\n  raster_width,\n  pixel_height,\n  pixel_width,\n  geometry,\n  per_pixel,\n  per_row_segment\n}) {\n  const [xmin, ymin, xmax, ymax] = raster_bbox;\n  if (pixel_height === undefined || pixel_height === null) pixel_height = (ymax - ymin) / raster_height;\n  if (pixel_width === undefined || pixel_width === null) pixel_width = (xmax - xmin) / raster_width;\n\n  const rows = new Array(raster_height);\n\n  calculateCallbacks({\n    raster_bbox,\n    raster_height,\n    raster_width,\n    pixel_height,\n    pixel_width,\n    geometry,\n    per_pixel,\n    per_row_segment: ({ row, columns }) => {\n      if (!rows[row]) rows[row] = [];\n      rows[row].push(columns);\n      if (per_row_segment) per_row_segment({ row, columns });\n    }\n  });\n\n  for (let irow = 0; irow < rows.length; irow++) {\n    const ranges = rows[irow];\n    if (ranges) {\n      // sort from left to right\n      ranges.sort((a, b) => (a === b ? a[1] - b[1] : a[0] - b[0]));\n\n      // replace existing row with sorted and merged one\n      rows[irow] = mergeConsecutiveRanges(ranges);\n    }\n  }\n\n  if (debug) checkRows(insides);\n\n  return { rows };\n};\n","module.exports = function categorizeIntersection(segments) {\n  try {\n    let through, xmin, xmax;\n\n    const n = segments.length;\n\n    const first = segments[0];\n\n    if (n === 1) {\n      through = true;\n      xmin = first.xmin;\n      xmax = first.xmax;\n    } /* n > 1 */ else {\n      const last = segments[n - 1];\n      through = first.direction === last.direction;\n      xmin = Math.min(first.xmin, last.xmin);\n      xmax = Math.max(first.xmax, last.xmax);\n    }\n\n    if (xmin === undefined || xmax === undefined || through === undefined || isNaN(xmin) || isNaN(xmax)) {\n      throw Error(\"categorizeIntersection failed with xmin\", xmin, \"and xmax\", xmax);\n    }\n\n    return { xmin, xmax, through };\n  } catch (error) {\n    console.error(\"[categorizeIntersection] segments:\", segments);\n    console.error(\"[categorizeIntersection]\", error);\n    throw error;\n  }\n};\n","module.exports = function checkRanges(rows) {\n  rows.forEach((ranges, irow) => {\n    for (let irange = 0; irange < ranges.length; irange++) {\n      const range = ranges[irange];\n      const [start, end] = range;\n      if (start > end) {\n        console.warn(\"[dufour-peyton-intersection] uh oh, encountered invalid range\", range, \"at row index\", irow, \"with ranges\", ranges);\n      }\n\n      for (let iother = irange + 1; iother < ranges.length; iother++) {\n        if (iother[0] <= end) {\n          console.warn(\"[dufour-peyton-intersection] encountered range problem on row index\", irow, \":\", ranges);\n        }\n      }\n    }\n  });\n};\n","module.exports = function clamp(n, min, max) {\n  if (n < min) return min;\n  else if (n > max) return max;\n  return n;\n};\n","const cluster = require(\"./cluster.js\");\n\nmodule.exports = function clusterLineSegments(lineSegments, numberOfEdges, debug = false) {\n  try {\n    const clusters = cluster(lineSegments, s => s.endsOffLine);\n\n    const numberOfClusters = clusters.length;\n\n    if (numberOfClusters >= 2) {\n      const firstCluster = clusters[0];\n      const firstSegment = firstCluster[0];\n      const lastCluster = clusters[clusters.length - 1];\n      const lastSegment = lastCluster[lastCluster.length - 1];\n\n      if (lastSegment.index === numberOfEdges - 1 && firstSegment.index === 0 && lastSegment.endsOnLine) {\n        clusters[0] = clusters.pop().concat(firstCluster);\n      }\n    }\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[clusterLineSegments]\", error);\n  }\n};\n","module.exports = function cluster(items, newClusterTest) {\n  try {\n    const numberOfItems = items.length;\n    const clusters = [];\n    let cluster = [];\n    for (let i = 0; i < numberOfItems; i++) {\n      const item = items[i];\n      cluster.push(item);\n      if (newClusterTest(item)) {\n        clusters.push(cluster);\n        cluster = [];\n      }\n    }\n\n    if (cluster.length > 0) clusters.push(cluster);\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[cluster]:\", error);\n  }\n};\n","// This function takes in an array with an even number of elements and\n// returns an array that couples every two consecutive elements;\nmodule.exports = function couple(array) {\n  const couples = [];\n  const lengthOfArray = array.length;\n  for (let i = 0; i < lengthOfArray; i += 2) {\n    couples.push([array[i], array[i + 1]]);\n  }\n  return couples;\n};\n","module.exports = function eachEdge(polygon, callback) {\n  polygon.forEach(ring => {\n    for (let i = 1; i < ring.length; i++) {\n      // should reuse previous endPoint as startPoint to save memory\n      const startPoint = ring[i - 1];\n      const endPoint = ring[i];\n      const edgeIndex = i - 1;\n      callback([startPoint, endPoint], edgeIndex);\n    }\n  });\n};\n","const getDepth = require(\"get-depth\");\n\n// call callback function for each polygon in geojson\nmodule.exports = function eachPolygon(geojson, callback) {\n  if (geojson.type === \"FeatureCollection\") {\n    geojson.features.forEach(feature => eachPolygon(feature, callback));\n  } else if (geojson.type === \"Feature\") {\n    eachPolygon(geojson.geometry, callback);\n  } else if (geojson.type === \"Polygon\") {\n    eachPolygon(geojson.coordinates, callback);\n  } else if (geojson.type === \"MultiPolygon\") {\n    geojson.coordinates.forEach(polygon => {\n      callback(polygon);\n    });\n  } else if (Array.isArray(geojson)) {\n    const depth = getDepth(geojson);\n    if (depth === 4) {\n      geojson.forEach(polygon => {\n        callback(polygon);\n      });\n    } else if (depth === 3) {\n      callback(geojson);\n    }\n  }\n};\n","const eachPolygon = require(\"./each-polygon.js\");\n\nmodule.exports = function getBoundingBox(geometry) {\n  let xmin, ymin, xmax, ymax;\n\n  eachPolygon(geometry, polygon => {\n    const ring = polygon[0]; // only want the exterior ring\n    const imax = ring.length - 1;\n\n    let i;\n    if (xmin === undefined) {\n      xmin = xmax = ring[0][0];\n      ymin = ymax = ring[0][1];\n      i = 1;\n    } else {\n      i = 0;\n    }\n\n    for (; i <= imax; i++) {\n      const [x, y] = ring[i];\n      if (x < xmin) xmin = x;\n      else if (x > xmax) xmax = x;\n      if (y < ymin) ymin = y;\n      else if (y > ymax) ymax = y;\n    }\n  });\n\n  return [xmin, ymin, xmax, ymax];\n};\n","const eachEdge = require(\"./each-edge.js\");\n\nmodule.exports = function getEdges(polygon) {\n  const edges = [];\n  eachEdge(polygon, edge => edges.push(edge));\n  return edges;\n};\n","// function to get the point at which two lines intersect\n// the input uses the line representations from the\n// getLineFromPoints function\nmodule.exports = function getIntersectionOfTwoLines(line1, line2) {\n  // calculate the determinant, ad - cb in a square matrix |a b|\n  const det = line1.a * line2.b - line2.a * line1.b; /*  |c d| */\n\n  if (det) {\n    // this makes sure the lines aren't parallel, if they are, det will equal 0\n    const x = (line2.b * line1.c - line1.b * line2.c) / det;\n    const y = (line1.a * line2.c - line2.a * line1.c) / det;\n    return { x, y };\n  }\n};\n","// function to convert two points into a\n// representation of a line\nmodule.exports = function getLineFromPoints(startPoint, endPoint) {\n  // get a, b, and c from line equation ax + by = c\n  const [x1, y1] = startPoint;\n  const [x2, y2] = endPoint;\n  const a = y2 - y1;\n  const b = x1 - x2;\n  const c = a * x1 + b * y1;\n\n  // return just a b and c since that is all we need\n  // to compute the intersection\n  return { a, b, c };\n};\n","const eachPolygon = require(\"./each-polygon.js\");\n\nmodule.exports = function getPolygons(geojson) {\n  const polygons = [];\n  eachPolygon(geojson, polygon => polygons.push(polygon));\n  return polygons;\n};\n","const categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst cluster = require(\"./cluster.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst calculate = require(\"./calculate.js\");\nconst calculateCore = require(\"./calculate-core.js\");\nconst couple = require(\"./couple.js\");\nconst getBoundingBox = require(\"./get-bounding-box.js\");\nconst getPolygons = require(\"./get-polygons.js\");\nconst eachEdge = require(\"./each-edge.js\");\nconst getIntersectionOfTwoLines = require(\"./get-intersection-of-two-lines.js\");\nconst getLineFromPoints = require(\"./get-line-from-points.js\");\nconst mergeRanges = require(\"./merge-ranges.js\");\nconst partition = require(\"./partition.js\");\nconst prepareSnap = require(\"./prepare-snap.js\");\nconst range = require(\"./range.js\");\nconst roundDown = require(\"./round-down.js\");\n\nconst dufour_peyton_intersection = {\n  calculate,\n  calculateCore,\n  categorizeIntersection,\n  clamp,\n  cluster,\n  clusterLineSegments,\n  couple,\n  eachEdge,\n  getBoundingBox,\n  getIntersectionOfTwoLines,\n  getLineFromPoints,\n  getPolygons,\n  mergeRanges,\n  partition,\n  prepareSnap,\n  range,\n  roundDown\n};\n\nif (typeof define === \"function\" && define.amd) define(() => dufour_peyton_intersection);\nif (typeof module === \"object\") module.exports = dufour_peyton_intersection;\nif (typeof self == \"object\") self.dufour_peyton_intersection = dufour_peyton_intersection;\nif (typeof window == \"object\") window.dufour_peyton_intersection = dufour_peyton_intersection;\n","module.exports = function mergeConsecutiveRanges(ranges) {\n  const numberOfRanges = ranges.length;\n  if (numberOfRanges > 0) {\n    const firstRange = ranges[0];\n    let previousEnd = firstRange[1];\n    const result = [firstRange];\n    for (let i = 1; i < numberOfRanges; i++) {\n      const tempRange = ranges[i];\n      const [start, end] = tempRange;\n      if (start <= previousEnd + 1) {\n        result[result.length - 1][1] = end;\n      } else {\n        result.push(tempRange);\n      }\n      previousEnd = end;\n    }\n    return result;\n  }\n};\n","// This function takes in an array of number pairs and combines where there's overlap\nmodule.exports = function mergeRanges(ranges) {\n  const numberOfRanges = ranges.length;\n  if (numberOfRanges > 0) {\n    const firstRange = ranges[0];\n    let previousEnd = firstRange[1];\n    const result = [firstRange];\n    for (let i = 1; i < numberOfRanges; i++) {\n      const tempRange = ranges[i];\n      const [start, end] = tempRange;\n      if (start <= previousEnd) {\n        result[result.length - 1][1] = end;\n      } else {\n        result.push(tempRange);\n      }\n      previousEnd = end;\n    }\n    return result;\n  }\n};\n","module.exports = function partition(array, filter) {\n  const passed = [];\n  const unpassed = [];\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    const item = array[i];\n    if (filter(item)) passed.push(item);\n    else unpassed.push(item);\n  }\n  return [passed, unpassed];\n};\n","const roundDown = require(\"./round-down.js\");\n\n/**\n * @name prepareSnap\n * @description snap horizontal range in crs to model space\n * @private\n * @param {Number} raster_xmin\n * @param {Number} pixel_width\n * @return {([Number, Number]) => [Number, Number]}\n */\nmodule.exports = function prepareSnap(raster_xmin, pixel_width) {\n  return ([xmin, xmax]) => {\n    // use roundDown so 1.5 is rounded to 1 not 2\n    xmin = roundDown((xmin - raster_xmin) / pixel_width);\n    if (xmin === -0) xmin = 0;\n\n    xmax = Math.round((xmax - raster_xmin) / pixel_width);\n    if (xmax === -0) xmax = 0;\n\n    return [xmin, xmax];\n  };\n};\n","module.exports = function range(count) {\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) result[i] = i;\n  return result;\n};\n","/**\n * @name roundDown\n * @description like Math.round, but numbers in the middle are rounded down not up\n * @param {Number} n\n * @returns {Number} rounded number\n */\nmodule.exports = function roundDown(n) {\n  return -1 * Math.round(-1 * n);\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(138);\n"],"names":["module","exports","arr","isArray","Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","depth","part","getLineFromPoints","categorizeIntersection","clamp","couple","clusterLineSegments","getEdges","getIntersectionOfTwoLines","getPolygons","mergeRanges","partition","prepareSnap","range","debug_level","raster_bbox","raster_height","raster_width","pixel_height","pixel_width","geometry","per_pixel","per_row_segment","raster_xmin","raster_ymin","raster_xmax","raster_ymax","imageLines","y","lat","line","push","console","log","map","forEach","edges","intersectionsByRow","numberOfEdges","length","i","edge","startPoint","endPoint","x1","y1","x2","y2","direction","Math","sign","horizontal","vertical","edgeY","edgeLine","edgeYMin","min","edgeYMax","max","startLng","startLat","endLat","endLng","undefined","Error","imageY1","round","imageY2","rowStart","rowEnd","j","imageLine","error","imageLineY","c","startsOnLine","endsOnLine","endsOffLine","xminOnLine","xmaxOnLine","x","index","xmin","xmax","half_pixel_width","snap","segmentsInRow","row_index","categorized","throughs","nonthroughs","item","through","JSON","stringify","insides","intersection","sort","a","b","couples","left","right","concat","pair","start_column_index","end_column_index","row","columns","column_index","column","calculateCallbacks","checkRows","mergeConsecutiveRanges","debug","ymin","ymax","rows","irow","ranges","segments","n","first","last","isNaN","irange","start","end","warn","iother","cluster","lineSegments","clusters","s","firstCluster","firstSegment","lastCluster","lastSegment","pop","items","newClusterTest","numberOfItems","array","lengthOfArray","polygon","callback","ring","getDepth","eachPolygon","geojson","type","features","feature","coordinates","imax","eachEdge","line1","line2","det","polygons","calculate","calculateCore","getBoundingBox","dufour_peyton_intersection","roundDown","self","window","numberOfRanges","firstRange","previousEnd","result","tempRange","filter","passed","unpassed","len","count","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const clean = require("./clean.js");

function absolute(n) {
  n = clean(n);
  if (n[0] === "-") return n.substring(1);
  else return n;
}

module.exports = absolute;
module.exports.default = absolute;

},{"./clean.js":3}],2:[function(require,module,exports){
const compare_positive = require("./compare_positive.js");
const clean = require("./clean.js");
const long_addition = require("./long_addition.js");
const long_subtraction = require("./long_subtraction.js");

function add(a, b) {
  a = clean(a);
  b = clean(b);

  const apos = a[0] !== "-";
  const bpos = b[0] !== "-";

  if (apos && bpos) {
    return long_addition(a, b);
  } else if (!apos && !bpos) {
    return "-" + long_addition(a.substring(1), b.substring(1));
  } else if (!apos && bpos) {
    a = a.substring(1);
    switch (compare_positive(a, b)) {
      case "=":
        return "0";
      case "<":
        return long_subtraction(b, a);
      case ">":
        return "-" + long_subtraction(a, b);
    }
  } else if (apos && !bpos) {
    b = b.substring(1);
    switch (compare_positive(a, b)) {
      case "=":
        return "0";
      case "<":
        return "-" + long_subtraction(b, a);
      case ">":
        return long_subtraction(a, b);
    }
  }
}

module.exports = add;
module.exports.default = add;

},{"./clean.js":3,"./compare_positive.js":4,"./long_addition.js":8,"./long_subtraction.js":11}],3:[function(require,module,exports){
const expand = require("./expand.js");

module.exports = function clean(n) {
  // remove + from beginning
  if (n[0] === "+") n = n.substring(1);

  n = expand(n);

  // remove extra zero in front
  // 03938.123 => 3938.123
  n = n.replace(/^0+(?=\d)/, "");

  // remove extra zero at end
  if (n.includes(".")) n = n.replace(/\.?0+$/, "");

  // should improve this, so it identifies zero earlier
  if (n === "") n = "0";

  return n;
};

},{"./expand.js":7}],4:[function(require,module,exports){
const clean = require("./clean.js");

// given:
//  - a and b are positive numbers
//  - a and b have been cleaned (i.e. no + or leading zeros)
function compare_positive(a, b) {
  const alen = a.length;
  const blen = b.length;

  const aidx = a.indexOf(".");
  const bidx = b.indexOf(".");

  // basically where would the dot be
  // if we add a dot at the end of integers
  // like 123.
  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;

  // how much you need to shift the second number
  // to line up the decimal with the first
  //        0.12345
  //    12345.0

  const offset = a_adjusted_dot_index - b_adjusted_dot_index;

  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);

  let right = Math.max(alen - a_adjusted_dot_index, blen - b_adjusted_dot_index);

  let aoffset = offset < 0 ? -1 * offset : 0;
  let boffset = offset <= 0 ? 0 : offset;

  let imax = left + 1 + right - 1; // -1 for zero-index

  let i = 0;
  while (i < imax) {
    const ai = i - aoffset;
    const achar = ai === a_adjusted_dot_index ? "." : a[ai] || "0";
    const bi = i - boffset;
    const bchar = bi === b_adjusted_dot_index ? "." : b[bi] || "0";
    if (achar !== bchar) {
      if (achar > bchar) return ">";
      else if (achar < bchar) return "<";
    }
    i++;
  }

  return "=";
}

module.exports = compare_positive;
module.exports.default = compare_positive;

},{"./clean.js":3}],5:[function(require,module,exports){
// Internet Explorer doesn't support Number.MAX_SAFE_INTEGER
// so we just define the constant ourselves
const MAX_SAFE_INTEGER = 9007199254740991;

// the greatest number of digits an integer can have
// and be guaranteed to be stored safely as a floating point.
// subtract 1 because MAX_SAFE_INTEGER isn't all 9's
const MAX_SAFE_INTEGER_LENGTH = MAX_SAFE_INTEGER.toString().length - 1;

module.exports = {
  MAX_SAFE_INTEGER,
  MAX_SAFE_INTEGER_LENGTH
};

},{}],6:[function(require,module,exports){
const absolute = require("./absolute.js");
const clean = require("./clean.js");
const long_division = require("./long_division.js");

function divide(dividend, divisor, options) {
  dividend = clean(dividend);
  divisor = clean(divisor);

  if (divisor === "0") throw new Error("[preciso] division by zero");

  // sometimes dividend can be cleaned to ""
  if (dividend === "" || dividend === "0") return "0";

  const dividend_is_positive = dividend[0] !== "-";
  const divisor_is_positive = divisor[0] !== "-";

  const out_sign = dividend_is_positive !== divisor_is_positive ? "-" : "";

  if (!dividend_is_positive) dividend = absolute(dividend);
  if (!divisor_is_positive) divisor = absolute(divisor);

  return out_sign + long_division(dividend, divisor, options);
}

module.exports = divide;
module.exports.default = divide;

},{"./absolute.js":1,"./clean.js":3,"./long_division.js":9}],7:[function(require,module,exports){
// convert exponential notation to normal string
// not optimized yet and no support for big numbers
function expand(n) {
  // remove + from beginning
  if (n[0] === "+") n = n.substring(1);

  const sign = n[0] === "-" ? "-" : "";
  if (sign === "-") n = n.substring(1);

  const index_of_e = n.indexOf("e");

  // number not in exponential notation
  if (index_of_e === -1) return sign + n;

  let index_of_dot = n.indexOf(".");

  // if number doesn't include a period dot
  // then just assume it at the end
  // such that 3e4 has index of dot at 1
  if (index_of_dot === -1) index_of_dot = index_of_e;

  const shift = Number(n.substring(index_of_e + 1));

  // remove old decimal place
  const base = n.substring(0, index_of_e).replace(".", "");

  // normalize shift to start of the string at index zero
  const normshift = index_of_dot + shift;

  const baselen = base.length;

  if (normshift >= baselen) {
    const zct = normshift - baselen;
    let result = base;
    for (let i = 0; i < zct; i++) result += "0";
    return sign + result;
  } else if (normshift < 0) {
    // need to add zeros in decimal places
    result = "0.";
    for (let i = 0; i > normshift; i--) result += "0";
    result += base;
    return sign + result;
  } else {
    // shifting within the base
    return sign + base.substring(0, normshift) + "." + base.substring(normshift);
  }
}

module.exports = expand;
module.exports.default = expand;

},{}],8:[function(require,module,exports){
const { MAX_SAFE_INTEGER_LENGTH } = require("./constants.js");

// assumes both numbers are positive numbers
module.exports = function long_addition(a, b) {
  const alen = a.length;
  const blen = b.length;

  const aidx = a.indexOf(".");
  const bidx = b.indexOf(".");

  // basically where would the dot be
  // if we add a dot at the end of integers
  // like 123.
  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;

  // just use floating point arithmetic for small integers
  if (aidx === -1 && bidx === -1 && alen < MAX_SAFE_INTEGER_LENGTH && blen < MAX_SAFE_INTEGER_LENGTH) {
    return (Number(a) + Number(b)).toFixed();
  }

  // how much you need to shift the second number
  // to line up the decimal with the first
  //        0.12345
  //    12345.0

  const offset = a_adjusted_dot_index - b_adjusted_dot_index;

  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);

  let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);

  let aoffset = offset < 0 ? -1 * offset : 0;
  let boffset = offset <= 0 ? 0 : offset;

  let imax = left + 1 + right - 1; // -1 for zero-index

  let result = "";

  let carried = 0;

  // to the right of the period
  //        0.12345
  //    12345.0
  let i = imax;
  if (right > 0) {
    while (i > imax - right) {
      const achar = a[i - aoffset] || "0";
      const bchar = b[i - boffset] || "0";
      let n = Number(achar) + Number(bchar) + carried;
      if (n >= 10) {
        n -= 10;
        carried = 1;
      } else {
        carried = 0;
      }
      if (result !== "" || n !== 0) {
        result = n + result;
      }
      i--;
    }
    if (result) result = "." + result;
    i--; // substract 1 for dot
  }

  if (left > 0) {
    while (i >= 0) {
      const achar = a[i - aoffset] || "0";
      const bchar = b[i - boffset] || "0";
      let n = Number(achar) + Number(bchar) + carried;
      if (n >= 10) {
        n -= 10;
        carried = 1;
      } else {
        carried = 0;
      }
      result = n + result;
      i--;
    }
  }

  if (carried === 1) {
    result = carried + result;
  }

  if (result[0] === ".") result = "0" + result;

  return result;
};

},{"./constants.js":5}],9:[function(require,module,exports){
const compare_positive = require("./compare_positive.js");
const add = require("./add.js");
const multiply = require("./multiply.js");
const subtract = require("./subtract.js");
const round_last_decimal = require("./round_last_decimal.js");

// given dividend and divisor are positive numberical strings
module.exports = function long_division(dividend, divisor, { max_decimal_digits = 100, ellipsis = false } = {}) {
  // remove unnecessary starting zeros
  // ex: 0.5 => .5
  if (dividend[0] === "0") dividend = dividend.substring(1);
  if (divisor[0] === "0") divisor = divisor.substring(1);

  const dividend_index_of_dot = dividend.indexOf(".");
  const divisor_index_of_dot = divisor.indexOf(".");

  const adjusted_dividend_index_of_dot = dividend_index_of_dot === -1 ? dividend.length : dividend_index_of_dot;
  const divisor_num_decimal_places = divisor_index_of_dot === -1 ? 0 : divisor.length - 1 - divisor_index_of_dot;

  // whether the result has a repeating decimal
  // e.g. 1/3 is repeating as in "0.333..."
  let repeating = false;

  // remove decimals
  dividend = dividend.replace(/\./, "");
  divisor = divisor.replace(/\./, "");

  const dividend_length = dividend.length;

  let current = "";
  let quotient = "";
  let comparison;
  let offset = -1 * divisor_num_decimal_places;
  let skip = 0;
  for (let i = 0; i < dividend_length; i++) {
    const char = dividend[i];

    current += char;

    comparison = compare_positive(current, divisor);

    if (comparison === ">") {
      // same as const times = Math.floor(current / divisor);
      // but without floating point problems
      let times = 1;
      let product = add(divisor, divisor);
      let passed_product = divisor;
      while (compare_positive(product, current) !== ">") {
        times++;
        passed_product = product;
        product = add(product, divisor);
      }
      times = times.toString();

      if (quotient !== "") {
        for (let i = times.length; i <= skip; i++) quotient += "0";
      }
      quotient += times; // string concatentation

      current = subtract(current, passed_product);

      skip = 0;
    } else if (comparison === "<") {
      if (quotient === "") {
        offset++;
      }
      skip++;

      // outside greater than inside
      continue;
    } else if (comparison === "=") {
      if (quotient !== "") {
        for (let i = 0; i < skip; i++) quotient += "0";
      }
      quotient += "1";
      current = "0";
      skip = 0;
    }
  }

  if (current.match(/^0+$/g)) {
    if (comparison === "<") {
      quotient += current.substring(0, current.length - 1);
    }
  } else {
    const previous = {};

    // keep dividing until we have an answer
    // figure out current place of decimal number
    const idot = adjusted_dividend_index_of_dot - offset;
    const qlen = quotient.length;
    // add 1 extra for rounding purposes
    const imax = idot - qlen + max_decimal_digits + 1;

    // reset skip if just "" so far because don't want to count 0 in 0.
    if (quotient === "") {
      skip = 0;
    }

    for (let i = 0; i < imax; i++) {
      current += "0";
      if (ellipsis) {
        if (current in previous) {
          previous[current]++;
          if (previous[current] > 3) {
            quotient += "...";
            repeating = true;
            break;
          }
        } else {
          previous[current] = 1;
        }
      }
      const comparison = compare_positive(current, divisor);

      if (comparison === ">") {
        // inside greater than outside

        // how many times the divisor goes into the current
        let times = 1;
        let product = add(divisor, divisor);
        let passed_product = divisor;
        while (compare_positive(product, current) !== ">") {
          times++;
          passed_product = product;
          product = add(product, divisor);
        }

        times = times.toString();

        // pad left zeros
        for (let i = times.length; i <= skip; i++) quotient += "0";
        quotient += times; // string concatentation
        current = subtract(current, passed_product);

        if (current === "0") {
          break;
        }

        skip = 0;
      } else if (comparison === "<") {
        // outside greater than inside
        skip++;
        continue;
      } else if (comparison === "=") {
        // fill in previous with zeros
        for (let i = 0; i < skip; i++) quotient += "0";
        quotient += "1";
        skip = 0;
        break;
      }
    }
  }

  // reinsert decimal place

  const idot = adjusted_dividend_index_of_dot - offset;
  const qlen = quotient.length;

  let num_decimals;

  if (idot === qlen) {
    // integer number so don't do anything
    num_decimals = 0;
  } else if (idot < 0) {
    quotient = "0." + "0".repeat(Math.abs(idot)) + quotient;
    num_decimals = qlen - idot; // idot is negative, so adding
  } else if (idot > qlen) {
    // add more zeros to integer
    for (let i = qlen; i < idot; i++) quotient += "0";
    num_decimals = 0;
  } else if (idot < qlen) {
    quotient = quotient.substring(0, idot) + "." + quotient.substring(idot);
    num_decimals = qlen - idot;
  } else if (idot === 0) {
    quotient = "0." + quotient;
    num_decimals = qlen;
  }

  // remove zeros from front
  // 03938.123 => 3938.123
  quotient = quotient.replace(/^0+/, "");

  // remove extra zeros from the end
  quotient = quotient.replace(/\.\d+0+$/, "");

  // round if necessary
  if (!repeating) {
    const extra_decimals = num_decimals - max_decimal_digits;
    if (extra_decimals > 0) {
      quotient = round_last_decimal(quotient.substring(0, quotient.length - extra_decimals + 1));
    }
  }

  if (quotient[0] === ".") quotient = "0" + quotient;

  return quotient;
};

},{"./add.js":2,"./compare_positive.js":4,"./multiply.js":12,"./round_last_decimal.js":13,"./subtract.js":14}],10:[function(require,module,exports){
const { MAX_SAFE_INTEGER_LENGTH } = require("./constants.js");

const CHUNK_SIZE = 15;

/**
 *
 * @param {String} a - numerical string larger or equal to b
 * @param {String} b - numerical string smaller or equal to a
 * @returns {String} product - result of multiplying a with b
 */

module.exports = function long_multiplication(a, b) {
  if (a === "0" || b === "0") return "0";

  const top_index_of_dot = a.indexOf(".");
  const bottom_index_of_dot = b.indexOf(".");

  const a_num_integer_places = top_index_of_dot === -1 ? a.length : top_index_of_dot;
  const b_num_integer_places = bottom_index_of_dot === -1 ? b.length : bottom_index_of_dot;
  const max_total_num_integer_places = a_num_integer_places + b_num_integer_places;

  const a_num_decimal_places = top_index_of_dot === -1 ? 0 : a.length - 1 - top_index_of_dot;
  const b_num_decimal_places = bottom_index_of_dot === -1 ? 0 : b.length - 1 - bottom_index_of_dot;

  const out_num_decimal_places = a_num_decimal_places + b_num_decimal_places;

  if (out_num_decimal_places === 0 && max_total_num_integer_places < MAX_SAFE_INTEGER_LENGTH) {
    return (Number(a) * Number(b)).toFixed(0);
  }

  // remove decimals
  const aint = a.replace(".", "");
  const bint = b.replace(".", "");

  const alen = aint.length;
  const blen = bint.length;

  const chunks = [];
  let i = alen;
  while (i >= 0) {
    const end = i;
    const start = (i -= CHUNK_SIZE);
    const str = aint.substring(start, end);
    chunks.push([Number(str), str.length]);
  }

  const partial_products = [];
  const partials = [];

  // for each number in multiplier
  for (let i = 0, ireverse = blen - 1; ireverse >= 0; ireverse--, i++) {
    const bstr = bint[ireverse];

    const bnum = Number(bstr);

    let carried = 0;
    let partial = "";
    const ichunklast = chunks.length - 1;
    chunks.forEach(([chunk, chunklen], c) => {
      const subpartial = carried + bnum * chunk;
      let subpartstr = subpartial.toString();
      const subpartcharlen = subpartstr.length;
      if (subpartcharlen > chunklen && c !== ichunklast) {
        const islice = -1 * chunklen;
        partial = subpartstr.slice(islice) + partial;
        carried = Number(subpartstr.slice(0, islice));
      } else {
        const imax = chunklen - subpartcharlen;
        for (let i = 0; i < imax; i++) {
          subpartstr = "0" + subpartstr;
        }
        carried = 0;
        partial = subpartstr + partial;
      }
    });

    // add number of zeros at end
    partial += "0".repeat(i);

    partial_products.push(partial);

    partials.push([Array.from(partial).map(char => Number(char)), partial.length]);
  }

  // back to front, iterate through columns
  // and add partial products together
  const num_partials = partial_products.length;

  const number_of_columns = partials[partials.length - 1][1] + num_partials;

  let result = "";
  let carried = 0;
  for (let icol = 0; icol < number_of_columns; icol++) {
    let sum = carried;
    const pmax = Math.min(icol, num_partials - 1);
    for (let p = 0; p <= pmax; p++) {
      const [pnums, plen] = partials[p];
      const i = plen - 1 - icol;
      if (i >= 0) {
        sum += pnums[i];
      }
    }

    if (sum >= 10) {
      sum = sum.toString();
      result = sum[sum.length - 1] + result;
      carried = Number(sum.slice(0, -1));
    } else {
      result = sum + result;
      carried = 0;
    }
  }

  // add decimal back in
  if (out_num_decimal_places === 0) {
    // integer
    // remove extra zeros
    result = result.replace(/^0+/, "");
  } else {
    // decimal number
    const idot = result.length - out_num_decimal_places;

    result = result.substring(0, idot) + "." + result.substring(idot);

    // remove zeros from front
    result = result.replace(/^0+/, "");

    // remove extra zeros from the end
    result = result.replace(/\.?0+$/, "");

    if (result[0] === ".") result = "0" + result;
  }

  return result;
};

},{"./constants.js":5}],11:[function(require,module,exports){
// const lookup = {};
// const vals = [undefined, 0, 1, 2, 3, 4, 5, 6, 8, 9];
// vals.forEach(top => {
//   lookup[top] = {};
//   vals.forEach(bottom => {
//     lookup[top][bottom] = (top || 0) - (bottom || 0);
//   })
// });

const { MAX_SAFE_INTEGER_LENGTH } = require("./constants.js");

// assumes (1) both a and b are positive numbers
// and (2) a is larger than b
module.exports = function long_subtraction(a, b) {
  const alen = a.length;
  const blen = b.length;

  const aidx = a.indexOf(".");
  const bidx = b.indexOf(".");

  // basically where would the dot be
  // if we add a dot at the end of integers
  // like 123.
  const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
  const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
  // console.log({a_adjusted_dot_index, b_adjusted_dot_index});

  // how much you need to shift the second number
  // to line up the decimal with the first
  //        0.12345
  //    12345.0

  // just use floating point arithmetic for small integers
  if (aidx === -1 && bidx === -1 && alen < MAX_SAFE_INTEGER_LENGTH && blen < MAX_SAFE_INTEGER_LENGTH) {
    return (Number(a) - Number(b)).toFixed();
  }

  const offset = a_adjusted_dot_index - b_adjusted_dot_index;
  // console.log("offset:", offset);

  let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
  // console.log("left:", left);

  let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);
  // console.log("right:", right);

  let aoffset = offset < 0 ? -1 * offset : 0;
  let boffset = offset <= 0 ? 0 : offset;
  // console.log({aoffset, boffset});

  let imax = left + 1 + right - 1; // -1 for zero-index
  // console.log({imax});

  let result = "";

  // number of borrowings
  let borrowed = 0;

  // to the right of the period
  //  100.5  6  7
  //    2.2  9  3
  //        (-3 + 10)  4
  let i = imax;
  if (right > 0) {
    while (i > imax - right) {
      // console.log("\n\n", {i});
      let top = a[i - aoffset] || "0";
      let bottom = b[i - boffset] || "0";

      // console.log("pre borrowing", {top, bottom});
      top -= borrowed;
      borrowed = 0;

      // console.log("after borrowing", {top, bottom});
      let n = top - bottom;

      // console.log({n});
      if (n < 0) {
        while (n < 0) {
          borrowed++;
          n += 10;
        }
      } else if (borrowed) {
        borrowed--;
      }
      // console.log({n});
      if (result !== "" || n !== 0) {
        result = n + result;
      }
      i--;
    }
    if (result !== "") {
      result = "." + result;
    }
    i--; // substract 1 for dot
  }

  // console.log({result});

  if (left > 0) {
    while (i > 0) {
      // console.log("\n\n", {i});
      let top = a[i - aoffset] || "0";
      let bottom = b[i - boffset] || "0";

      // console.log("pre borrowing", {top, bottom});
      top -= borrowed;
      borrowed = 0;

      // console.log("after borrowing", {top, bottom});
      let n = top - bottom;

      // console.log({n});
      if (n < 0) {
        while (n < 0) {
          borrowed++;
          n += 10;
        }
      } else if (borrowed) {
        borrowed--;
      }
      // console.log({n});
      result = n + result;
      i--;
    }

    // console.log({borrowed});
    // special rule for last one
    const achar = a[0 - aoffset] || "0";
    const bchar = b[0 - boffset] || "0";
    let n = Number(achar) - (borrowed > 0 ? 1 : 0) - Number(bchar);
    if (n !== 0) {
      result = n + result;
    }

    // remove any zeros in front like in 0123
    result = result.replace(/^0+/, "");
  }

  // if decimal number add zero
  if (result[0] === ".") result = "0" + result;

  return result;
};

},{"./constants.js":5}],12:[function(require,module,exports){
const absolute = require("./absolute.js");
const clean = require("./clean.js");
const compare_positive = require("./compare_positive.js");
const long_multiplication = require("./long_multiplication.js");

function multiply(a, b) {
  a = clean(a);
  b = clean(b);

  const apos = a[0] !== "-";
  const bpos = b[0] !== "-";

  const out_sign = apos !== bpos ? "-" : "";

  a = absolute(a);
  b = absolute(b);

  const comparison = compare_positive(a, b);

  if (comparison === "<") {
    const aold = a;
    const bold = b;
    a = bold;
    b = aold;
  }

  return out_sign + long_multiplication(a, b);
}

module.exports = multiply;
module.exports.default = multiply;

},{"./absolute.js":1,"./clean.js":3,"./compare_positive.js":4,"./long_multiplication.js":10}],13:[function(require,module,exports){
// given n is a decimal number
const up = ["5", "6", "7", "8", "9"];
module.exports = function round_last_decimal(n) {
  // remove + from beginning
  if (n[0] === "+") n = n.substring(1);

  //console.log("rounding:", {n});
  const len = n.length;
  //console.log({len});
  let result = "";

  const last_char = n[n.length - 1];
  //console.log({last_char});

  if (up.includes(last_char)) {
    let i;
    for (i = len - 2; i >= 0; i--) {
      const char = n[i];
      //console.log({char});
      // skip over . or -
      if (char === "." || char === "-") continue;

      const nchar = Number(char) + 1;
      //console.log({nchar});

      if (nchar === 10) {
        result = "0" + result;
        // keep rounding up
      } else {
        result = nchar + result;
        break;
      }
    }
    //console.log({i});
    if (i > 0) result = n.substring(0, i) + result;
  } else {
    result = n.substring(0, len - 1);
  }

  if (result[result.length - 1] === ".") result = result.substring(0, result.length - 1);

  // remove trailing zeros in decimal number
  // 0.50 => 0.5
  if (result.indexOf(".") > -1) result = result.replace(/0+$/, "");

  return result;
};

},{}],14:[function(require,module,exports){
const clean = require("./clean");
const compare_positive = require("./compare_positive.js");
const long_addition = require("./long_addition.js");
const long_subtraction = require("./long_subtraction.js");

function subtract(a, b) {
  a = clean(a);
  b = clean(b);

  const a_is_positive = a[0] !== "-";
  const b_is_positive = b[0] !== "-";
  if (a_is_positive) {
    if (b_is_positive) {
      const comparison = compare_positive(a, b);
      if (comparison === ">") {
        return long_subtraction(a, b);
      } else if (comparison === "<") {
        return "-" + long_subtraction(b, a);
      } else {
        return "0";
      }
    } else {
      return long_addition(a, b.substring(1));
    }
  } else if (b_is_positive) {
    return "-" + long_addition(a.substring(1), b);
  } else {
    a = a.substring(1);
    b = b.substring(1);
    const comparison = compare_positive(a, b);
    if (comparison === ">") {
      return "-" + long_subtraction(a, b);
    } else if (comparison === "<") {
      return long_subtraction(b, a);
    } else {
      return "0";
    }
  }
}

module.exports = subtract;
module.exports.default = subtract;

},{"./clean":3,"./compare_positive.js":4,"./long_addition.js":8,"./long_subtraction.js":11}],15:[function(require,module,exports){
function count({ nums, no_data }) {
  let len = nums.length;
  const counts = {};
  let total = 0;
  if (no_data !== undefined) {
    for (let i = 0; i < len; i++) {
      const n = nums[i];
      if (n !== no_data) {
        total++;
        if (n in counts) counts[n].ct++;
        else counts[n] = { n, ct: 1 };
      }
    }
  } else {
    for (let i = 0; i < len; i++) {
      const n = nums[i];
      total++;
      if (n in counts) counts[n].ct++;
      else counts[n] = { n, ct: 1 };
    }
  }
  return { counts, total };
}

module.exports = count;
module.exports.default = count;

},{}],16:[function(require,module,exports){
const median_of_a_lot = require("./median-of-a-lot.js");
const median_of_a_few = require("./median-of-a-few.js");

function calculate({ counts, nums, no_data, precise, threshold = 50, total }) {
  if (counts !== undefined || total !== undefined || nums.length > threshold) {
    return median_of_a_lot({ counts, no_data, nums, precise, total });
  } else {
    return median_of_a_few({ no_data, nums, precise });
  }
}

const mediana = { calculate };

if (typeof define === "function" && define.amd) {
  define(function () {
    return mediana;
  });
}

if (typeof module === "object") {
  module.exports = mediana;
  module.exports.default = { calculate };
}

if (typeof window === "object") {
  window.mediana = mediana;
}

if (typeof self === "object") {
  self.mediana = mediana;
}

},{"./median-of-a-few.js":18,"./median-of-a-lot.js":19}],17:[function(require,module,exports){
const add = require("preciso/add");
const divide = require("preciso/divide");

function mean(a, b, { precise = false } = { precise: false }) {
  if (precise) {
    return divide(add(a.toString(), b.toString()), "2");
  } else {
    return (a + b) / 2;
  }
}

module.exports = mean;
module.exports.default = mean;

},{"preciso/add":2,"preciso/divide":6}],18:[function(require,module,exports){
const mean = require("./mean");

function median_of_a_few({ nums, no_data, precise = false }) {
  nums = nums.filter(n => n !== no_data).sort((a, b) => a - b);
  switch (nums.length) {
    case 0:
      return undefined;
    case 1:
      return precise ? nums[0].toString() : nums[0];
    default:
      const mid = nums.length / 2;
      if (nums.length % 2 === 0) {
        return mean(nums[mid - 1], nums[mid], { precise });
      } else {
        const i = Math.floor(mid);
        return precise ? nums[i].toString() : nums[i];
      }
  }
}

module.exports = median_of_a_few;
module.exports.default = median_of_a_few;

},{"./mean":17}],19:[function(require,module,exports){
const count = require("./count");
const mean = require("./mean");

function median_of_a_lot({ counts, nums, no_data, precise = false, total }) {
  if (counts === undefined || total === undefined) {
    ({ counts, total } = count({ nums, no_data }));
  }

  // sort counts by value
  const countArray = Object.values(counts).sort((a, b) => a.n - b.n);
  const half = total / 2;
  const number_of_unique_values = countArray.length;
  if (number_of_unique_values === 0) {
    return undefined;
  } else if (number_of_unique_values === 1) {
    return precise ? countArray[0].n.toString() : countArray[0].n;
  } else {
    let x = 0;

    if (total % 2 === 0) {
      for (let i = 0; i < number_of_unique_values; i++) {
        const { n, ct } = countArray[i];
        x += ct;
        if (x > half) {
          // handle if odd or even
          // just barely pass cut off
          if (x - ct === half) {
            return mean(countArray[i - 1].n, n, { precise });
          } else {
            return precise ? n.toString() : n;
          }
        }
      }
    } else {
      for (let i = 0; i < number_of_unique_values; i++) {
        const { n, ct } = countArray[i];
        x += ct;
        if (x > half) return precise ? n.toString() : n;
      }
    }
  }
}

module.exports = median_of_a_lot;
module.exports.default = median_of_a_lot;

},{"./count":15,"./mean":17}]},{},[16]);

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addAlpha;

/**
 * @description adds an alpha channel to an RGB Pixel, creating a new RGBA pixel
 * @param rgb - a 3-number RGB pixel
 * @returns rgba - a 4-number array representing an RGBA pixel
 */
function addAlpha(rgb) {
  return [...rgb, 255];
}
},{}],2:[function(require,module,exports){
"use strict";

var _addAlpha = _interopRequireDefault(require("./add-alpha"));

var _hasNoData = _interopRequireDefault(require("./has-no-data"));

var _hideRgba = _interopRequireDefault(require("./hide-rgba"));

var _isHidden = _interopRequireDefault(require("./is-hidden"));

var _isNoData = _interopRequireDefault(require("./is-no-data"));

var _makeNoDataRgb = _interopRequireDefault(require("./make-no-data-rgb"));

var _makeNoDataRgba = _interopRequireDefault(require("./make-no-data-rgba"));

var _fit = _interopRequireDefault(require("./fit"));

var _popAlpha = _interopRequireDefault(require("./pop-alpha"));

var _range = _interopRequireDefault(require("./range"));

var _rawToRgb = _interopRequireDefault(require("./raw-to-rgb"));

var _rawToRgba = _interopRequireDefault(require("./raw-to-rgba"));

var _rgbToRgba = _interopRequireDefault(require("./rgb-to-rgba"));

var _rgbaToRgb = _interopRequireDefault(require("./rgba-to-rgb"));

var _setHidden = _interopRequireDefault(require("./set-hidden"));

var _setVisible = _interopRequireDefault(require("./set-visible"));

var _showRgba = _interopRequireDefault(require("./show-rgba"));

var _sliceAlpha = _interopRequireDefault(require("./slice-alpha"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pixelUtils = {
  addAlpha: _addAlpha.default,
  fit: _fit.default,
  hasNoData: _hasNoData.default,
  hideRgba: _hideRgba.default,
  isHidden: _isHidden.default,
  isNoData: _isNoData.default,
  makeNoDataRgb: _makeNoDataRgb.default,
  makeNoDataRgba: _makeNoDataRgba.default,
  popAlpha: _popAlpha.default,
  range: _range.default,
  rawToRgb: _rawToRgb.default,
  rawToRgba: _rawToRgba.default,
  rgbToRgba: _rgbToRgba.default,
  rgbaToRgb: _rgbaToRgb.default,
  setHidden: _setHidden.default,
  setVisible: _setVisible.default,
  showRgba: _showRgba.default,
  sliceAlpha: _sliceAlpha.default
};
if (typeof define === "function" && define.amd) define(() => pixelUtils);
if (typeof module === "object") module.exports = pixelUtils;
if (typeof window === "object") window.pixelUtils = pixelUtils;
if (typeof self === "object") self.pixelUtils = pixelUtils;
},{"./add-alpha":1,"./fit":4,"./has-no-data":5,"./hide-rgba":6,"./is-hidden":7,"./is-no-data":8,"./make-no-data-rgb":9,"./make-no-data-rgba":10,"./pop-alpha":11,"./range":13,"./raw-to-rgb":22,"./raw-to-rgba":28,"./rgb-to-rgba":29,"./rgba-to-rgb":33,"./set-hidden":44,"./set-visible":45,"./show-rgba":46,"./slice-alpha":47}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layout = void 0;
let Layout;
exports.Layout = Layout;

(function (Layout) {
  Layout["[band][row][column]"] = "[band][row][column]";
  Layout["[band][row,column]"] = "[band][row,column]";
  Layout["[band,row,column]"] = "[band,row,column]";
  Layout["[row,column,band]"] = "[row,column,band]";
  Layout["[row,column][band]"] = "[row,column][band]";
  Layout["[row][column][band]"] = "[row][column][band]";
  Layout["[row][column,band]"] = "[row][column,band]";
})(Layout || (exports.Layout = Layout = {}));
},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fit;

var _xdim = require("xdim");

var _rawToRgba = _interopRequireDefault(require("../raw-to-rgba"));

var _selectPixel = _interopRequireDefault(require("../select-pixel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// fit raw bands to 8-bit color space
// while slicing and scaling as necessary
function fit({
  data,
  debug_level = 0,
  depth,
  flip = false,
  old_no_data_value,
  old_layout,
  no_data_strategy = "partial",
  // png strategy
  no_range_value,
  no_range_value_strategy = "top",
  new_layout,
  new_no_data_value,
  height,
  ranges,
  width
}) {
  if (!ranges) throw new Error("[expand] can't expand without ranges");
  if (debug_level >= 1) console.log("[stretch] starting fit");
  if (typeof height !== "number") throw new Error("[fit] height must be a number");
  if (typeof width !== "number") throw new Error("[fit] height must be a number");
  if (typeof old_layout !== "string") throw new Error("[fit] old_layout must be a string");
  if (new_layout === undefined) new_layout === "[row,column,band]";
  if (typeof new_layout !== "string") throw new Error("[fit] new_layout must be a string");
  const select = (0, _selectPixel.default)(data, {
    depth,
    height,
    layout: old_layout,
    width
  });
  const out_sizes = {
    band: 4,
    row: height,
    column: width
  };
  const {
    data: out_data
  } = (0, _xdim.prepareData)({
    fill: new_no_data_value,
    layout: new_layout,
    sizes: out_sizes
  });
  const convert = (0, _rawToRgba.default)({
    debug_level: debug_level - 1,
    flip,
    ranges: ranges,
    new_no_data_value: new_no_data_value,
    no_data_strategy: no_data_strategy,
    no_range_value: no_range_value,
    no_range_value_strategy: no_range_value_strategy,
    old_no_data_value
  });
  const update = (0, _xdim.prepareUpdate)({
    data: out_data,
    layout: new_layout,
    sizes: out_sizes
  });

  for (let row = 0; row < height; row++) {
    for (let column = 0; column < width; column++) {
      const [r, g, b, a] = convert(select(row, column));
      update({
        point: {
          band: 0,
          row,
          column
        },
        value: r
      });
      update({
        point: {
          band: 1,
          row,
          column
        },
        value: g
      });
      update({
        point: {
          band: 2,
          row,
          column
        },
        value: b
      });
      update({
        point: {
          band: 3,
          row,
          column
        },
        value: a
      });
    }
  }

  if (debug_level >= 1) console.log("[pixel-utils/fit] out_data:", out_data);
  return {
    // @ts-ignore
    data: out_data,
    layout: new_layout
  };
}
},{"../raw-to-rgba":28,"../select-pixel":36,"xdim":52}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hasNoData;

function hasNoData(noDataValue, pixel) {
  return pixel.includes(noDataValue);
}
},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hide_rgba;

/**
 * @name hide_rgba
 * @description make a given (scaled) rgba value transparent/invisble
 * @param {RGBA} rgba pixel
 * @returns a new rgba pixel with the same Red, Green and Blue values and a 0 alpha value
 */
function hide_rgba([r, g, b]) {
  return [r, g, b, 0];
}
},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isHidden;

/**
 * @description check if an RGBA pixel is hidden
 * @param {number[]} pixel - an array of 4 numbers representing [R, G, B, A]
 * @returns {boolean} whether the pixel is hidden
 */
function isHidden(pixel) {
  return pixel[3] === 0;
}
},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNoData;

/**
 * @description check if an RGB pixel is a no data pixel
 * @param {number} no_data_value
 * @param {number[]} pixel - an array of 4 numbers representing [R, G, B, A]
 * @returns {boolean} whether the pixel is a no data pixel
 */
function isNoData(no_data_value, pixel) {
  return pixel[0] === no_data_value;
}
},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeNoDataRGB;

function makeNoDataRGB(noDataValue) {
  // typescript not smart enough to realize all values in the array will be the same
  // @ts-ignore
  return [noDataValue, noDataValue, noDataValue];
}
},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeNoDataRgba;

function makeNoDataRgba(noDataValue) {
  // typescript not smart enough to realize all values in the array will be the same
  // @ts-ignore
  return [noDataValue, noDataValue, noDataValue, 0];
}
},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = popAlpha;

/**
 *
 * @param {Pixel} pixel - an RGBA Pixel, an Array of 4 Numbers [Red, Green, Blue, Alpha]
 * @returns {RGBA} an RGB Pixel, an Array of 3 Numbers [Red, Green, Blue]
 */
function popAlpha(pixel) {
  pixel.pop(); // @ts-ignore

  return pixel;
}
},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pushAlpha;

/**
 * @description converts an RGB to an RGBA by pushing an alpha value at the end of the RGB array
 * @param rgb - a 3-number RGB pixel
 * @returns rgba - a 4-number array representing an RGBA pixel
 */
function pushAlpha(pixel) {
  // @ts-ignore
  pixel.push(255); // @ts-ignore

  return pixel;
}
},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = range;

function range(ct) {
  return new Array(ct).fill(0).map((_, i) => i);
}
},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_two_band_pixel_to_rgb_str;

function convert_raw_two_band_pixel_to_rgb_str(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", 0)";
}
},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_two_band_pixel_to_rgb;

function convert_raw_two_band_pixel_to_rgb(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), 0];
}
},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_two_band_pixel_to_rgb_str;

function convert_raw_two_band_pixel_to_rgb_str(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  pixel = pixel.slice(0, 3);
  if (pixel.includes(noDataValue)) return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", " + scaleFunction3(pixel[2]) + ")";
}
},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_two_band_pixel_to_rgb;

function convert_raw_two_band_pixel_to_rgb(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  pixel = pixel.slice(0, 3);
  if (pixel.includes(noDataValue)) return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), scaleFunction3(pixel[2])];
}
},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_one_band_pixel_to_rgb_str;

function convert_raw_one_band_pixel_to_rgb_str(noDataValue, noDataPixel, scale, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  const scaled = scale(pixel[0]);
  return "rgb(" + scaled + ", " + scaled + ", " + scaled + ")";
}
},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_one_band_pixel_to_rgb;

function convert_raw_one_band_pixel_to_rgb(noDataValue, noDataPixel, scale, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  const scaled = scale(pixel[0]);
  return [scaled, scaled, scaled];
}
},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_three_band_pixel_to_rgb_css;

function convert_raw_three_band_pixel_to_rgb_css(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", " + scaleFunction3(pixel[2]) + ")";
}
},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_raw_three_band_pixel_to_rgb;

function convert_raw_three_band_pixel_to_rgb(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  if (pixel.includes(noDataValue)) return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), scaleFunction3(pixel[2])];
}
},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rawToRgb;

var _quickScale = require("quick-scale");

var _makeNoDataRgb = _interopRequireDefault(require("../make-no-data-rgb"));

var _convertSingle = _interopRequireDefault(require("./convert-single"));

var _convertSingleStr = _interopRequireDefault(require("./convert-single-str"));

var _convertDouble = _interopRequireDefault(require("./convert-double"));

var _convertDoubleStr = _interopRequireDefault(require("./convert-double-str"));

var _convertTriple = _interopRequireDefault(require("./convert-triple"));

var _convertTripleStr = _interopRequireDefault(require("./convert-triple-str"));

var _convertMany = _interopRequireDefault(require("./convert-many"));

var _convertManyStr = _interopRequireDefault(require("./convert-many-str"));

var _rgbToStr = _interopRequireDefault(require("../rgb-to-str"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rawToRgb({
  format = "array",
  ranges,
  flip,
  new_no_data_pixel,
  new_no_data_value,
  no_range_value,
  no_range_value_strategy,
  old_no_data_value,
  round = true
}) {
  const nbands = ranges.length;

  if (new_no_data_pixel && new_no_data_value) {
    throw new Error("[pixel-utils/raw-to-rgb] can't specify both new_no_data_pixel and new_no_data_value");
  }

  if (new_no_data_pixel === undefined || new_no_data_pixel === null) {
    if (new_no_data_value === undefined || new_no_data_value === null) {
      new_no_data_pixel = (0, _makeNoDataRgb.default)(null);
    } else {
      new_no_data_pixel = (0, _makeNoDataRgb.default)(new_no_data_value);
    }
  }

  if (new_no_data_pixel === undefined) throw new Error("[raw-to-rgb] undefined new_no_data_pixel");
  const new_range = [0 === new_no_data_value ? 1 : 0, 255 === new_no_data_value ? 254 : 255];
  const options = {
    flip,
    no_range_value,
    no_range_value_strategy,
    round
  };
  const scalefns = ranges.slice(0, 3).map(rng => (0, _quickScale.createScaleFunction)(rng, new_range, options));

  if (nbands === 1) {
    if (format === "string") {
      // @ts-ignore
      return _convertSingleStr.default.bind(null, old_no_data_value, (0, _rgbToStr.default)(new_no_data_pixel), ...scalefns);
    } else {
      // @ts-ignore
      return _convertSingle.default.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands === 2) {
    if (format === "string") {
      // @ts-ignore
      return _convertDoubleStr.default.bind(null, old_no_data_value, (0, _rgbToStr.default)(new_no_data_pixel), ...scalefns);
    } else {
      // @ts-ignore
      return _convertDouble.default.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands === 3) {
    if (format === "string") {
      // @ts-ignore
      return _convertTripleStr.default.bind(null, old_no_data_value, (0, _rgbToStr.default)(new_no_data_pixel), ...scalefns);
    } else {
      // @ts-ignore
      return _convertTriple.default.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands >= 4) {
    if (format === "string") {
      // @ts-ignore
      return _convertManyStr.default.bind(null, old_no_data_value, (0, _rgbToStr.default)(new_no_data_pixel), ...scalefns);
    } else {
      // @ts-ignore
      return _convertMany.default.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else {
    throw new Error("[pixel-utils/raw-to-rgb] invalid number of bands: " + nbands);
  }
}
},{"../make-no-data-rgb":9,"../rgb-to-str":32,"./convert-double":15,"./convert-double-str":14,"./convert-many":17,"./convert-many-str":16,"./convert-single":19,"./convert-single-str":18,"./convert-triple":21,"./convert-triple-str":20,"quick-scale":49}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_double_all;

// convert a 2-band pixel
// if any no data is found, set all RGB to no data
function convert_double_all(old_no_data_value, noDataPixel, scalefn1, scalefn2, pixel) {
  if (pixel.includes(old_no_data_value)) return noDataPixel;
  return [scalefn1(pixel[0]), scalefn2(pixel[1]), 0, 255];
}
},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_double;

function convert_double(old_no_data_value, new_no_data_value, scalefn1, scalefn2, pixel) {
  const [r, g] = pixel; // @ts-ignore

  return [r === old_no_data_value ? new_no_data_value : scalefn1(r), g === old_no_data_value ? new_no_data_value : scalefn2(g), 0, r === old_no_data_value || g === old_no_data_value ? 0 : 255];
}
},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_multiband_all;

function convert_multiband_all(old_no_data_value, noDataPixel, scalefn1, scalefn2, scalefn3, pixel) {
  if (pixel.includes(old_no_data_value)) return noDataPixel;
  return [scalefn1(pixel[0]), scalefn2(pixel[1]), scalefn3(pixel[2]), 255];
}
},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_multiband;

function convert_multiband(old_no_data_value, new_no_data_value, scalefn1, scalefn2, scalefn3, pixel) {
  const [r, g, b] = pixel;
  return [// @ts-ignore
  r === old_no_data_value ? new_no_data_value : scalefn1(r), // @ts-ignore
  g === old_no_data_value ? new_no_data_value : scalefn2(g), // @ts-ignore
  b === old_no_data_value ? new_no_data_value : scalefn3(b), // @ts-ignore
  r === old_no_data_value || g === old_no_data_value || b === old_no_data_value ? 0 : 255];
}
},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert_one;

function convert_one(old_no_data_value, noDataPixel, scalefn, pixel) {
  const n = pixel[0];
  if (n === old_no_data_value) return noDataPixel;
  const scaled = scalefn(n);
  return [scaled, scaled, scaled, 255];
}
},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rawToRgba;

var _quickScale = require("quick-scale");

var _makeNoDataRgba = _interopRequireDefault(require("../make-no-data-rgba"));

var _convertSingle = _interopRequireDefault(require("./convert-single"));

var _convertDouble = _interopRequireDefault(require("./convert-double"));

var _convertDoubleAll = _interopRequireDefault(require("./convert-double-all"));

var _convertMultiband = _interopRequireDefault(require("./convert-multiband"));

var _convertMultibandAll = _interopRequireDefault(require("./convert-multiband-all"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rawToRgba({
  debug_level = 0,
  ranges,
  flip = false,
  new_no_data_value,
  no_data_strategy,
  no_range_value,
  no_range_value_strategy,
  old_no_data_value
}) {
  if (debug_level >= 1) console.log("[pixel-utils/raw-to-rgba] ranges:", ranges);
  const nbands = ranges.length;
  const new_range = [0 === new_no_data_value ? 1 : 0, 255 === new_no_data_value ? 254 : 255];
  if (debug_level >= 1) console.log("[pixel-utils/raw-to-rgba] new_range:", new_range);
  const options = {
    no_data_value: new_no_data_value,
    flip,
    no_range_value,
    no_range_value_strategy,
    round: true
  };
  if (debug_level >= 1) console.log("[pixel-utils/raw-to-rgba] options:", options);
  const scalefns = ranges.slice(0, 3).map(rng => (0, _quickScale.createScaleFunction)(rng, new_range, options));

  if (nbands === 1) {
    // @ts-ignore
    return _convertSingle.default.bind(null, old_no_data_value, (0, _makeNoDataRgba.default)(new_no_data_value), scalefns[0]);
  } else if (nbands === 2) {
    if (no_data_strategy === "all") {
      // @ts-ignore
      return _convertDoubleAll.default.bind(null, old_no_data_value, (0, _makeNoDataRgba.default)(new_no_data_value), ...scalefns);
    } else {
      // @ts-ignore
      return _convertDouble.default.bind(null, old_no_data_value, new_no_data_value, ...scalefns);
    }
  } else if (nbands >= 3) {
    if (no_data_strategy === "all") {
      // @ts-ignore
      return _convertMultibandAll.default.bind(null, old_no_data_value, (0, _makeNoDataRgba.default)(new_no_data_value), ...scalefns);
    } else {
      // @ts-ignore
      return _convertMultiband.default.bind(null, old_no_data_value, new_no_data_value, ...scalefns);
    }
  }

  throw Error("uh oh");
}
},{"../make-no-data-rgba":10,"./convert-double":24,"./convert-double-all":23,"./convert-multiband":26,"./convert-multiband-all":25,"./convert-single":27,"quick-scale":49}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rgbToRgba;

var _addAlpha = _interopRequireDefault(require("../add-alpha"));

var _pushAlpha = _interopRequireDefault(require("../push-alpha"));

var _makeNoDataRgba = _interopRequireDefault(require("../make-no-data-rgba"));

var _safelyConvert = _interopRequireDefault(require("./safely-convert"));

var _quicklyConvert = _interopRequireDefault(require("./quickly-convert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rgbToRgba({
  old_no_data_value,
  new_no_data_value = null,
  safe = true
} = {}) {
  if (typeof old_no_data_value === "number") {
    if (safe) {
      // @ts-ignore
      return _safelyConvert.default.bind(null, old_no_data_value, new_no_data_value);
    } else {
      const new_no_data_pixel = (0, _makeNoDataRgba.default)(new_no_data_value); // we will reuse this no data pixel
      // @ts-ignore

      return _quicklyConvert.default.bind(null, old_no_data_value, new_no_data_pixel);
    }
  } else {
    if (safe) {
      return _addAlpha.default;
    } else {
      return _pushAlpha.default;
    }
  }
}
},{"../add-alpha":1,"../make-no-data-rgba":10,"../push-alpha":12,"./quickly-convert":30,"./safely-convert":31}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quickly_convert;

var _isNoData = _interopRequireDefault(require("../is-no-data"));

var _pushAlpha = _interopRequireDefault(require("../push-alpha"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// assuming valid RGB input
function quickly_convert(old_no_data_value, new_no_data_pixel, px) {
  return (0, _isNoData.default)(old_no_data_value, px) ? new_no_data_pixel : (0, _pushAlpha.default)(px);
}
},{"../is-no-data":8,"../push-alpha":12}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = safely_convert_rgb_to_rgba;

var _addAlpha = _interopRequireDefault(require("../add-alpha"));

var _isNoData = _interopRequireDefault(require("../is-no-data"));

var _makeNoDataRgba = _interopRequireDefault(require("../make-no-data-rgba"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function safely_convert_rgb_to_rgba(old_no_data_value, new_no_data_value, pixel) {
  return (0, _isNoData.default)(old_no_data_value, pixel) ? (0, _makeNoDataRgba.default)(new_no_data_value) : (0, _addAlpha.default)(pixel);
}
},{"../add-alpha":1,"../is-no-data":8,"../make-no-data-rgba":10}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rgbToStr;

// prettier-ignore
function rgbToStr([r, g, b]) {
  return "rgb(" + r + ", " + g + ", " + b + ")";
}
},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rgbaToRgb;

var _makeNoDataRgb = _interopRequireDefault(require("../make-no-data-rgb"));

var _popAlpha = _interopRequireDefault(require("../pop-alpha"));

var _sliceAlpha = _interopRequireDefault(require("../slice-alpha"));

var _safelyConvert = _interopRequireDefault(require("./safely-convert"));

var _quicklyConvert = _interopRequireDefault(require("./quickly-convert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// converting from RGBA to RGB
// where we no longer have an alpha value
// assuming pixel is already scaled
// assume no data pixels have zero transparency
function rgbaToRgb({
  new_no_data_value,
  safe = true
} = {}) {
  if (safe) {
    if (typeof new_no_data_value === "number") {
      // @ts-ignore
      return _safelyConvert.default.bind(null, new_no_data_value);
    } else {
      return _sliceAlpha.default;
    }
  } else {
    if (typeof new_no_data_value === "number") {
      // @ts-ignore
      return _quicklyConvert.default.bind(null, (0, _makeNoDataRgb.default)(new_no_data_value));
    } else {
      return _popAlpha.default;
    }
  }
}
},{"../make-no-data-rgb":9,"../pop-alpha":11,"../slice-alpha":47,"./quickly-convert":34,"./safely-convert":35}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quickly_convert_rgba_to_rgb;

var _isHidden = _interopRequireDefault(require("../is-hidden"));

var _popAlpha = _interopRequireDefault(require("../pop-alpha"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function quickly_convert_rgba_to_rgb(noDataPixel, pixel) {
  return (0, _isHidden.default)(pixel) ? noDataPixel : (0, _popAlpha.default)(pixel);
}
},{"../is-hidden":7,"../pop-alpha":11}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = safely_convert_rgba_to_rgb;

var _isHidden = _interopRequireDefault(require("../is-hidden"));

var _makeNoDataRgb = _interopRequireDefault(require("../make-no-data-rgb"));

var _sliceAlpha = _interopRequireDefault(require("../slice-alpha"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function safely_convert_rgba_to_rgb(noDataValue, pixel) {
  return (0, _isHidden.default)(pixel) ? (0, _makeNoDataRgb.default)(noDataValue) : (0, _sliceAlpha.default)(pixel);
}
},{"../is-hidden":7,"../make-no-data-rgb":9,"../slice-alpha":47}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = selectPixel;

var _enums = require("../enums");

var _selectPixelFromBrc = _interopRequireDefault(require("./select-pixel-from-brc"));

var _selectPixelFromBRC = _interopRequireDefault(require("./select-pixel-from-b-r-c"));

var _selectPixelFromBRc = _interopRequireDefault(require("./select-pixel-from-b-rc"));

var _selectPixelFromRcb = _interopRequireDefault(require("./select-pixel-from-rcb"));

var _selectPixelFromRcB = _interopRequireDefault(require("./select-pixel-from-rc-b"));

var _selectPixelFromRCB = _interopRequireDefault(require("./select-pixel-from-r-c-b"));

var _selectPixelFromRCb = _interopRequireDefault(require("./select-pixel-from-r-cb"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function selectPixel(data, {
  depth,
  height,
  layout,
  width
}) {
  // console.log("layout:", {layout, data, depth, width});
  switch (layout) {
    case _enums.Layout["[band][row][column]"]:
      // @ts-ignore
      return _selectPixelFromBRC.default.bind(null, data, depth);

    case _enums.Layout["[band][row,column]"]:
      // @ts-ignore
      return _selectPixelFromBRc.default.bind(null, data, depth, width);

    case _enums.Layout["[band,row,column]"]:
      // @ts-ignore
      return _selectPixelFromBrc.default.bind(null, data, depth, height, width);

    case _enums.Layout["[row,column][band]"]:
      // @ts-ignore
      return _selectPixelFromRcB.default.bind(null, data, width);

    case _enums.Layout["[row][column][band]"]:
      // @ts-ignore
      return _selectPixelFromRCB.default.bind(null, data);

    case _enums.Layout["[row][column,band]"]:
      // @ts-ignore
      return _selectPixelFromRCb.default.bind(null, data, depth);

    case _enums.Layout["[row,column,band]"]:
      // @ts-ignore
      return _selectPixelFromRcb.default.bind(null, data, depth, width);

    default:
      throw new Error("[pixel-utils] unknown layout " + layout);
  }
}
},{"../enums":3,"./select-pixel-from-b-r-c":37,"./select-pixel-from-b-rc":38,"./select-pixel-from-brc":39,"./select-pixel-from-r-c-b":40,"./select-pixel-from-r-cb":41,"./select-pixel-from-rc-b":42,"./select-pixel-from-rcb":43}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_b_r_c;

function select_b_r_c(data, depth, r, c) {
  const pixel = [];

  for (let b = 0; b < depth; b++) {
    pixel.push(data[b][r][c]);
  }

  return pixel;
}
},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_b_rc;

function select_b_rc(data, depth, width, r, c) {
  const pixel = [];
  const i = r * width + c;

  for (let b = 0; b < depth; b++) {
    pixel.push(data[b][i]);
  }

  return pixel;
}
},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_brc;

function select_brc(data, depth, height, width, r, c) {
  const pixel = [];
  const size = height * width;
  const i = r * width + c;

  for (let b = 0; b < depth; b++) {
    pixel.push(data[b * size + i]);
  }

  return pixel;
}
},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_r_c_b;

function select_r_c_b(data, r, c) {
  return data[r][c];
}
},{}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_r_cb;

// each row is its own array
function select_r_cb(data, depth, r, c) {
  const pixel = [];
  const row = data[r];
  let i = c * depth;
  const imax = i + depth;

  for (; i < imax; i++) {
    pixel.push(row[i]);
  }

  return pixel;
}
},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_rc_b;

function select_rc_b(data, width, r, c) {
  return data[r * width + c];
}
},{}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select_rcb;

// like ImageData.data
function select_rcb(data, depth, width, r, c) {
  const pixel = [];
  let i = (r * width + c) * depth;
  const imax = i + depth;

  for (; i < imax; i++) {
    pixel.push(data[i]);
  }

  return pixel;
}
},{}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setHidden;

// make a given rgba value transparent
function setHidden(pixel) {
  // @ts-ignore
  pixel[3] = 0; // @ts-ignore

  return pixel;
}
},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setVisible;

// make a given rgba value visible
function setVisible(pixel) {
  // @ts-ignore
  pixel[3] = 255; // @ts-ignore

  return pixel;
}
},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = showRGBA;

/**
 * @name show_rgba
 * @description // make a given (scaled) rgba value visible
 * @param {RGBA} rgba pixel
 * @returns a new rgba pixel with the same Red, Green and Blue values and a 255 alpha value
 */
function showRGBA([r, g, b]) {
  return [r, g, b, 255];
}
},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sliceAlpha;

/**
 * @name sliceAlpha
 * @description slices off the alpha value of a 4-number RGBA pixel array,
 * leaving a new 3-Number RGB pixel array
 * @param {RGBA} pixel - an RGBA
 * @returns {RGBA} an RGBA pixel as an array of 4 numbers
 */
function sliceAlpha(pixel) {
  // @ts-ignore
  return pixel.slice(0, 3);
}
},{}],48:[function(require,module,exports){
function addSymbolIterator(obj) {
  try {
    obj[Symbol.iterator] = function () {
      return this;
    };
  } catch (error) {
    // pass
  }
}

function addSymbolIteratorFallback(obj) {
  obj["@@iterator"] = function () {
    return this;
  };
}

function wrapNextFunction(next) {
  const iter = { next };
  addSymbolIterator(iter);
  addSymbolIteratorFallback(iter);
  return iter;
}

function isArray(data) {
  try {
    return data.constructor.name.endsWith("Array");
  } catch {
    return false;
  }
}

function hasNext(data) {
  try {
    return typeof data.next === "function";
  } catch {
    return false;
  }
}

function hasIterator(data) {
  try {
    return "@@iterator" in data;
  } catch {
    return false;
  }
}

function hasSymbolIterator(data) {
  try {
    return Symbol.iterator in data.constructor.prototype;
  } catch {
    return false;
  }
}

function isIterator(data) {
  try {
    return (
      Symbol.iterator in data &&
      typeof data.next === "function" &&
      data.propertyIsEnumerable("next") === false
    );
  } catch {
    return false;
  }
}

function getIterator(data) {
  const iter = data["@@iterator"];
  if (hasNext(iter)) {
    return iter;
  } else if (typeof iter === "function") {
    return iter();
  }
}

function createIterator(data) {
  let i = 0;
  let len = data.length;
  const next = () =>
    i++ < len ? { value: data[i], done: false } : { done: true };
  return wrapNextFunction(next);
}

function getOrCreateIterator(data) {
  if (isIterator(data)) {
    return data;
  } else if (hasSymbolIterator(data)) {
    return data[Symbol.iterator]();
  } else if (hasNext(data)) {
    return wrapNextFunction(data.next);
  } else if (hasIterator(data)) {
    return getIterator(data);
  } else if (typeof data === "string" || isArray(data)) {
    return createIterator(data);
  } else {
    throw "[iter-fun] unable to determine iterator";
  }
}

function zip(iters) {
  // convert input to iters just in case
  iters = iters.map(getOrCreateIterator);

  return wrapNextFunction(function next() {
    const values = iters.map(iter => iter.next());
    // if they are all done, stop
    if (values.every(({ done }) => done)) {
      return { done: true };
    } else {
      return {
        done: false,
        value: values.map(({ value }) => value)
      };
    }
  });
}

if (typeof module === "object") {
  module.exports = {
    addSymbolIterator,
    addSymbolIteratorFallback,
    isIterator,
    isArray,
    hasNext,
    hasSymbolIterator,
    hasIterator,
    getIterator,
    createIterator,
    getOrCreateIterator,
    wrapNextFunction,
    zip
  };
}

},{}],49:[function(require,module,exports){
// to-do: provide offsets, so evenly distributed when rounding

function _identity(n) {
  return n;
}

function _scale_number(old_min, old_range, new_min, new_range, n) {
  return new_min + (new_range * (n - old_min)) / old_range;
}

function _scale_and_flip_number(old_min, old_range, new_max, new_range, n) {
  return new_max - (new_range * (n - old_min)) / old_range;
}

function _scale_and_round_number(old_min, old_range, new_min, new_range, n) {
  return Math.round(new_min + (new_range * (n - old_min)) / old_range);
}

function _scale_and_flip_and_round_number(old_min, old_range, new_max, new_range, n) {
  return Math.round(new_max - (new_range * (n - old_min)) / old_range);
}

// assuming not no data
function createScaleFunction([old_min, old_max], [new_min, new_max], { flip, no_range_value, no_range_value_strategy = "highest", round = false } = {}) {
  const old_range = old_max - old_min;
  const new_range = new_max - new_min;

  if (old_range === 0) {
    if (typeof no_range_value === "number") {
      return _identity.bind(null, no_range_value);
    } else if (no_range_value_strategy === "highest") {
      return _identity.bind(null, new_max);
    } else if (no_range_value_strategy === "lowest") {
      return _identity.bind(null, new_min);
    } else if (no_range_value_strategy === "middle") {
      let n = (new_max - new_min) / 2;
      if (round) n = Math.round(n);
      return _identity.bind(null, n);
    }
  }

  if (flip) {
    if (round) {
      return _scale_and_flip_and_round_number.bind(null, old_min, old_range, new_max, new_range);
    } else {
      return _scale_and_flip_number.bind(null, old_min, old_range, new_max, new_range);
    }
  } else {
    if (round) {
      return _scale_and_round_number.bind(null, old_min, old_range, new_min, new_range);
    } else {
      return _scale_number.bind(null, old_min, old_range, new_min, new_range);
    }
  }
}

function _scale(pixel, ...rest) {
  return create(rest)(pixel);
}

const quickScale = {
  _identity,
  _scale,
  _scale_number,
  _scale_and_flip_number,
  _scale_and_round_number,
  _scale_and_flip_and_round_number,
  createScaleFunction
};

if (typeof define === "object")
  define(function () {
    return quickScale;
  });
if (typeof module === "object") module.exports = quickScale;
if (typeof window === "object") window.quickScale = quickScale;
if (typeof self === "object") self.quickScale = quickScale;

},{}],50:[function(require,module,exports){
module.exports = {
  "1": function ({ point }) { const parent = this.data; const index = point[this.d0v0]; return { parent, index, value: parent[index] }; },
  "2": function ({ point }) { const parent = this.data; const index = this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]; return { parent, index, value: parent[index] }; },
  "3": function ({ point }) { const parent = this.data; const index = this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]; return { parent, index, value: parent[index] }; },
  "4": function ({ point }) { const parent = this.data; const index = this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]+this.m0v3*point[this.d0v3]; return { parent, index, value: parent[index] }; },
  "5": function ({ point }) { const parent = this.data; const index = this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]+this.m0v3*point[this.d0v3]+this.m0v4*point[this.d0v4]; return { parent, index, value: parent[index] }; },
  "1,1": function ({ point }) { const parent = this.data[point[this.d0v0]]; const index = point[this.d1v0]; return { parent, index, value: parent[index] }; },
  "1,2": function ({ point }) { const parent = this.data[point[this.d0v0]]; const index = this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]; return { parent, index, value: parent[index] }; },
  "1,3": function ({ point }) { const parent = this.data[point[this.d0v0]]; const index = this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]; return { parent, index, value: parent[index] }; },
  "1,4": function ({ point }) { const parent = this.data[point[this.d0v0]]; const index = this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]+this.m1v3*point[this.d1v3]; return { parent, index, value: parent[index] }; },
  "1,5": function ({ point }) { const parent = this.data[point[this.d0v0]]; const index = this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]+this.m1v3*point[this.d1v3]+this.m1v4*point[this.d1v4]; return { parent, index, value: parent[index] }; },
  "1,1,1": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]]; const index = point[this.d2v0]; return { parent, index, value: parent[index] }; },
  "1,1,2": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]]; const index = this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]; return { parent, index, value: parent[index] }; },
  "1,1,3": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]]; const index = this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]; return { parent, index, value: parent[index] }; },
  "1,1,4": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]]; const index = this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]+this.m2v3*point[this.d2v3]; return { parent, index, value: parent[index] }; },
  "1,1,5": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]]; const index = this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]+this.m2v3*point[this.d2v3]+this.m2v4*point[this.d2v4]; return { parent, index, value: parent[index] }; },
  "1,1,1,1": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]]; const index = point[this.d3v0]; return { parent, index, value: parent[index] }; },
  "1,1,1,2": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]]; const index = this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]; return { parent, index, value: parent[index] }; },
  "1,1,1,3": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]]; const index = this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]; return { parent, index, value: parent[index] }; },
  "1,1,1,4": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]]; const index = this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]+this.m3v3*point[this.d3v3]; return { parent, index, value: parent[index] }; },
  "1,1,1,5": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]]; const index = this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]+this.m3v3*point[this.d3v3]+this.m3v4*point[this.d3v4]; return { parent, index, value: parent[index] }; },
  "1,1,1,1,1": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]]; const index = point[this.d4v0]; return { parent, index, value: parent[index] }; },
  "1,1,1,1,2": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]]; const index = this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]; return { parent, index, value: parent[index] }; },
  "1,1,1,1,3": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]]; const index = this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]; return { parent, index, value: parent[index] }; },
  "1,1,1,1,4": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]]; const index = this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]+this.m4v3*point[this.d4v3]; return { parent, index, value: parent[index] }; },
  "1,1,1,1,5": function ({ point }) { const parent = this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]]; const index = this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]+this.m4v3*point[this.d4v3]+this.m4v4*point[this.d4v4]; return { parent, index, value: parent[index] }; }
}
},{}],51:[function(require,module,exports){
module.exports = {
  "1": function ({ point, value }) { this.data[point[this.d0v0]] = value; },
  "2": function ({ point, value }) { this.data[this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]] = value; },
  "3": function ({ point, value }) { this.data[this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]] = value; },
  "4": function ({ point, value }) { this.data[this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]+this.m0v3*point[this.d0v3]] = value; },
  "5": function ({ point, value }) { this.data[this.m0v0*point[this.d0v0]+this.m0v1*point[this.d0v1]+this.m0v2*point[this.d0v2]+this.m0v3*point[this.d0v3]+this.m0v4*point[this.d0v4]] = value; },
  "1,1": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]] = value; },
  "1,2": function ({ point, value }) { this.data[point[this.d0v0]][this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]] = value; },
  "1,3": function ({ point, value }) { this.data[point[this.d0v0]][this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]] = value; },
  "1,4": function ({ point, value }) { this.data[point[this.d0v0]][this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]+this.m1v3*point[this.d1v3]] = value; },
  "1,5": function ({ point, value }) { this.data[point[this.d0v0]][this.m1v0*point[this.d1v0]+this.m1v1*point[this.d1v1]+this.m1v2*point[this.d1v2]+this.m1v3*point[this.d1v3]+this.m1v4*point[this.d1v4]] = value; },
  "1,1,1": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]] = value; },
  "1,1,2": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]] = value; },
  "1,1,3": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]] = value; },
  "1,1,4": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]+this.m2v3*point[this.d2v3]] = value; },
  "1,1,5": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][this.m2v0*point[this.d2v0]+this.m2v1*point[this.d2v1]+this.m2v2*point[this.d2v2]+this.m2v3*point[this.d2v3]+this.m2v4*point[this.d2v4]] = value; },
  "1,1,1,1": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]] = value; },
  "1,1,1,2": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]] = value; },
  "1,1,1,3": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]] = value; },
  "1,1,1,4": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]+this.m3v3*point[this.d3v3]] = value; },
  "1,1,1,5": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][this.m3v0*point[this.d3v0]+this.m3v1*point[this.d3v1]+this.m3v2*point[this.d3v2]+this.m3v3*point[this.d3v3]+this.m3v4*point[this.d3v4]] = value; },
  "1,1,1,1,1": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]][point[this.d4v0]] = value; },
  "1,1,1,1,2": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]][this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]] = value; },
  "1,1,1,1,3": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]][this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]] = value; },
  "1,1,1,1,4": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]][this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]+this.m4v3*point[this.d4v3]] = value; },
  "1,1,1,1,5": function ({ point, value }) { this.data[point[this.d0v0]][point[this.d1v0]][point[this.d2v0]][point[this.d3v0]][this.m4v0*point[this.d4v0]+this.m4v1*point[this.d4v1]+this.m4v2*point[this.d4v2]+this.m4v3*point[this.d4v3]+this.m4v4*point[this.d4v4]] = value; }
}
},{}],52:[function(require,module,exports){
const layoutCache = {};
const { wrapNextFunction } = require("iter-fun");
const preparedSelectFunctions = require("./prepared-select-funcs.js");
const preparedUpdateFunctions = require("./prepared-update-funcs.js");

function parseDimensions(str) {
  const dims = {};
  const re = /[A-Za-z]+/g;
  let arr;
  while ((arr = re.exec(str)) !== null) {
    const [match] = arr;
    dims[match] = {
      name: match
    };
  }
  return dims;
}

function normalizeLayoutString(str) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  let i = 0;
  return str.replace(/[A-Za-z]+/g, () => alphabet[i++]);
}

const parseVectors = str => str.match(/\[[^\]]+\]/g);

// "[row]" to "row"
const removeBraces = str => (str.startsWith("[") && str.endsWith("]") ? str.substring(1, str.length - 1) : str);

// "(row)" to "row"
const removeParentheses = str => (str.startsWith("(") && str.endsWith(")") ? str.substring(1, str.length - 1) : str);

// sort of like parsing a CSV except instead of " for quotes use (
const matchSequences = str => str.match(/(\(.*?\)|[^\(,\s]+)(?=\s*,|\s*$)/g);

const parseSequences = str => {
  // unwrap [...]
  str = removeBraces(str);

  // unwrap (...)
  str = removeParentheses(str);

  const seqs = matchSequences(str);

  if (seqs.length === 1) {
    return {
      type: "Vector",
      dim: seqs[0]
    };
  } else {
    return {
      type: "Matrix",
      parts: seqs.map(parseSequences)
    };
  }
};

function checkValidity(str) {
  const invalid = str.match(/[^ A-Za-z,\[\]]/g);
  if (invalid) {
    throw new Error("The following invalid characters were used: " + invalid.map(c => `"${c}"`).join(", "));
  } else {
    return true;
  }
}

function parse(str, { useLayoutCache = true } = { useLayoutCache: true }) {
  if (useLayoutCache && str in layoutCache) return layoutCache[str];

  checkValidity(str);

  const vectors = parseVectors(str);
  const dims = vectors.map(parseSequences);
  const result = {
    type: "Layout",
    summary: dims.map(it => (it.type === "Matrix" ? it.parts.length : 1)),
    dims
  };

  if (useLayoutCache) layoutCache[str] = result;

  return result;
}

function update({ useLayoutCache = true, data, layout, point, sizes = {}, value }) {
  if (typeof layout === "string") layout = parse(layout, { useLayoutCache });

  const { dims } = layout;
  for (let idim = 0; idim < dims.length; idim++) {
    const last = idim === dims.length - 1;
    const arr = dims[idim];
    let offset;
    if (arr.type === "Vector") {
      offset = point[arr.dim];
    } else {
      // arr.type assumed to be "Matrix"
      const { parts } = arr;
      offset = 0;
      let multiplier = 1;
      for (let i = parts.length - 1; i >= 0; i--) {
        const part = parts[i];
        const { dim } = part;
        offset += multiplier * point[dim];
        if (i > 0) {
          if (!(dim in sizes)) throw new Error(`you cannot calculate the location without knowing the size of the "${dim}" dimension.`);
          multiplier *= sizes[dim];
        }
      }
    }
    if (last) {
      data[offset] = value;
    } else {
      data = data[offset];
    }
  }
}

function prepareUpdate({ useLayoutCache = true, data, layout, sizes = {} }) {
  if (typeof layout === "string") {
    layout = parse(layout, { useLayoutCache });
  }
  const { dims } = layout;
  const numDims = dims.length;
  const multipliers = getMultipliers({ useLayoutCache, layout, sizes });
  const end = numDims - 1;

  const key = layout.summary.toString();
  if (key in preparedUpdateFunctions) {
    const _this = { data };
    layout.dims.map((it, depth) => {
      if (it.type === "Vector") {
        _this[`d${depth}v0`] = it.dim;
      } else if (it.type === "Matrix") {
        it.parts.forEach((part, ipart) => {
          _this[`d${depth}v${ipart}`] = part.dim;
          _this[`m${depth}v${ipart}`] = multipliers[part.dim];
        });
      }
    });

    return preparedUpdateFunctions[key].bind(_this);
  }

  return ({ point, value }) => {
    let currentData = data;
    for (let idim = 0; idim < numDims; idim++) {
      const last = idim === end;
      const arr = dims[idim];
      let offset;
      if (arr.type === "Vector") {
        offset = point[arr.dim];
      } else {
        // arr.type assumed to be "Matrix"
        offset = arr.parts.reduce((acc, { dim }) => acc + multipliers[dim] * point[dim], 0);
      }
      if (last) {
        currentData[offset] = value;
      } else {
        currentData = currentData[offset];
      }
    }
  };
}

function iterClip({ data, layout, order, rect = {}, sizes = {}, useLayoutCache = true }) {
  if (!data) throw new Error("[xdim] must specify data");
  if (!layout) throw new Error("[xdim] must specify layout");
  const points = iterPoints({ order, sizes, rect });
  return wrapNextFunction(function next() {
    const { value: point, done } = points.next();
    if (done) {
      return { done: true };
    } else {
      const { value } = select({ data, layout, point, sizes, useLayoutCache });
      return { done: false, value };
    }
  });
}

function validateRect({ rect = {} }) {
  if (rect) {
    for (let key in rect) {
      const value = rect[key];
      if (value.length !== 2) throw new Error(`[xdim] uh oh. invalid hyper-rectangle`);
      const [start, end] = value;
      if (start > end) throw new Error(`[xdim] uh oh. invalid range for "${key}".  Start of ${start} can't be greater than end of ${end}.`);
      if (start < 0) throw new Error(`[xdim] uh oh. invalid hyper-rectangle with start ${start}`);
    }
  }
}

function clip({ useLayoutCache = true, data, layout, rect, sizes = {}, flat = false, validate = true }) {
  if (validate) validateRect({ rect });

  if (typeof layout === "string") layout = parse(layout, { useLayoutCache });

  let datas = [data];

  layout.dims.forEach(arr => {
    let new_datas = [];
    datas.forEach(data => {
      if (arr.type === "Vector") {
        const [start, end] = rect[arr.dim];
        new_datas = new_datas.concat(data.slice(start, end + 1));
      } else {
        // only 2 types so must be arr.type === "Matrix"
        const { parts } = arr;
        let offsets = [0];
        let multiplier = 1;
        for (let i = parts.length - 1; i >= 0; i--) {
          const part = parts[i];
          // assume part.type === "Vector"
          const { dim } = part;
          const [start, end] = rect[dim];
          const new_offsets = [];
          for (let n = start; n <= end; n++) {
            offsets.forEach(offset => {
              new_offsets.push(offset + multiplier * n);
            });
          }
          offsets = new_offsets;
          multiplier *= sizes[dim];
        }
        offsets.forEach(offset => {
          new_datas.push(data[offset]);
        });
      }
    });
    datas = new_datas;
  });

  if (flat) {
    return {
      data: datas
    };
  }

  // prepareResult
  const out_sizes = Object.fromEntries(Object.entries(rect).map(([dim, [start, end]]) => [dim, end - start + 1]));

  const { data: out_data } = prepareData({
    layout,
    sizes: out_sizes
  });

  const max_depth = layout.dims.length;

  const step = (arr, depth) => {
    if (depth === max_depth) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = datas.shift();
      }
    } else {
      arr.forEach(sub => step(sub, depth + 1));
    }
  };
  step(out_data, 1);

  return { data: out_data };
}

function getMultipliers({ useLayoutCache = true, layout, sizes }) {
  if (typeof layout === "string") {
    layout = parse(layout, { useLayoutCache });
  }
  const { dims } = layout;
  const numDims = dims.length;
  let multipliers = {};
  for (let idim = 0; idim < numDims; idim++) {
    const arr = dims[idim];
    if (arr.type === "Vector") {
      multipliers[arr.dim] = 1;
    } else {
      // arr.type assumed to be "Matrix"
      const { parts } = arr;
      let multiplier = 1;
      for (let i = parts.length - 1; i >= 0; i--) {
        const { dim } = parts[i];
        multipliers[dim] = multiplier;
        multiplier *= sizes[parts[i].dim];
      }
    }
  }
  return multipliers;
}

function prepareSelect({ useLayoutCache = true, data, layout, sizes = {} }) {
  if (typeof layout === "string") {
    layout = parse(layout, { useLayoutCache });
  }
  const { dims } = layout;
  const numDims = dims.length;
  const multipliers = getMultipliers({ useLayoutCache, layout, sizes });
  const end = numDims - 1;

  const key = layout.summary.toString();
  if (key in preparedSelectFunctions) {
    const _this = { data };
    layout.dims.map((it, depth) => {
      if (it.type === "Vector") {
        _this[`d${depth}v0`] = it.dim;
      } else if (it.type === "Matrix") {
        it.parts.forEach((part, ipart) => {
          _this[`d${depth}v${ipart}`] = part.dim;
          _this[`m${depth}v${ipart}`] = multipliers[part.dim];
        });
      }
    });

    return preparedSelectFunctions[key].bind(_this);
  }

  return ({ point }) => {
    let currentData = data;
    for (let idim = 0; idim < numDims; idim++) {
      const last = idim === end;
      const arr = dims[idim];
      let offset;
      if (arr.type === "Vector") {
        offset = point[arr.dim];
      } else {
        // arr.type assumed to be "Matrix"
        offset = arr.parts.reduce((acc, { dim }) => acc + multipliers[dim] * point[dim], 0);
      }
      if (last) {
        return {
          index: offset,
          parent: currentData,
          value: currentData[offset]
        };
      } else {
        currentData = currentData[offset];
      }
    }
  };
}

function select({ useLayoutCache = true, data, layout, point, sizes = {} }) {
  // converts layout expression to a layout object
  if (typeof layout === "string") {
    layout = parse(layout, { useLayoutCache });
  }

  let parent;
  let index;
  let value = data;
  // dims are arrays
  const { dims } = layout;
  const len = dims.length;
  for (let idim = 0; idim < len; idim++) {
    const arr = dims[idim];
    if (arr.type === "Vector") {
      const i = point[arr.dim];
      parent = value;
      index = i;
      value = value[i];
    } else {
      // only 2 types so must be a Matrix
      const { parts } = arr;
      let offset = 0;
      let multiplier = 1;
      for (let i = parts.length - 1; i >= 0; i--) {
        const part = parts[i];
        if (part.type === "Vector") {
          const { dim } = part;
          offset += multiplier * point[dim];
          if (i > 0) {
            if (!(dim in sizes)) throw new Error(`you cannot calculate the location without knowing the size of the "${dim}" dimension.`);
            multiplier *= sizes[dim];
          }
        }
      }
      parent = value;
      index = offset;
      value = value[offset];
    }
  }

  return { index, value, parent };
}

// add dimension to an array until the limit reaches zero
function addDims({ arr, fill = undefined, lens }) {
  // no new dimensions to add
  if (lens.length === 0) return arr;

  const len = lens[0];
  if (lens.length === 0) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = new Array(len).fill(fill);
    }
  } else {
    for (let i = 0; i < arr.length; i++) {
      const sub = new Array(len).fill(fill);
      arr[i] = sub;
      addDims({ arr: sub, lens: lens.slice(1) });
    }
  }
  return arr;
}

function createMatrix({ fill = undefined, shape }) {
  const len = shape[0];
  const arr = new Array(len).fill(fill);
  return addDims({ arr, fill, lens: shape.slice(1) });
}

// generates an in-memory data structure to hold the data
function prepareData({ fill = undefined, layout, useLayoutCache = true, sizes }) {
  if (typeof layout === "string") layout = parse(layout, { useLayoutCache });

  // console.log("layout:", layout);
  const shape = layout.dims.map(it => {
    if (it.type === "Vector") {
      return sizes[it.dim];
    } else if (it.type === "Matrix") {
      return it.parts.reduce((total, part) => {
        console.log("part.dim:", part.dim);
        if (!(part.dim in sizes)) throw new Error(`[xdim] could not find "${part.dim}" in sizes: { ${Object.keys(sizes).join(", ")} }`);
        return total * sizes[part.dim];
      }, 1);
    }
  });

  const data = createMatrix({ fill, shape });

  return { data, shape };
}

// assume positive step
function iterRange({ start = 0, end = 100 }) {
  let i = start - 1;
  end = end + 1;
  return wrapNextFunction(function next() {
    i++;
    if (i === end) {
      return { done: true };
    } else {
      return { done: false, value: i };
    }
  });
}

// iterate over all the points, saving memory vs array
function iterPoints({ order, sizes, rect = {} }) {
  // names sorted by shortest dimension to longest dimension
  const names = Array.isArray(order) ? order : Object.keys(sizes).sort((a, b) => sizes[a] - sizes[b]);

  const iters = new Array(names.length);
  const current = {};
  for (let i = 0; i < names.length - 1; i++) {
    const name = names[i];
    const [start, end] = rect[name] || [0, sizes[name] - 1];
    iters[i] = iterRange({ start: start + 1, end });
    current[name] = start;
  }
  const lastName = names[names.length - 1];
  const [start, end] = rect[lastName] || [0, sizes[lastName] - 1];
  iters[iters.length - 1] = iterRange({ start: start, end });
  current[lastName] = start - 1;

  // permutate
  return wrapNextFunction(function next() {
    for (let i = iters.length - 1; i >= 0; i--) {
      const { value, done } = iters[i].next();

      if (done) {
        if (i === 0) {
          // we have exhausted all of the permutations
          return { done: true };
        }
      } else {
        // add iters for the remaining dims
        for (let ii = i + 1; ii < iters.length; ii++) {
          const nameii = names[ii];
          const [start, end] = rect[nameii] || [0, sizes[nameii] - 1];
          iters[ii] = iterRange({ start: start + 1, end });
          current[nameii] = start;
        }

        current[names[i]] = value;

        return { value: current, done: false };
      }
    }
  });
}

function transform({ data, fill = undefined, from, to, sizes, useLayoutCache = true }) {
  if (typeof from === "string") from = parse(from, { useLayoutCache });
  if (typeof to === "string") to = parse(to, { useLayoutCache });

  const { data: out_data } = prepareData({ fill, layout: to, sizes });

  const update = prepareUpdate({
    useLayoutCache,
    data: out_data,
    layout: to,
    sizes
  });

  const points = iterPoints({ sizes });

  for (point of points) {
    const { value } = select({
      data,
      layout: from,
      point,
      sizes
    });

    // insert into new frame
    update({
      point,
      value
    });
  }

  return { data: out_data };
}

module.exports = {
  checkValidity,
  createMatrix,
  iterClip,
  iterRange,
  iterPoints,
  matchSequences,
  parse,
  parseDimensions,
  parseSequences,
  parseVectors,
  prepareData,
  prepareSelect,
  prepareUpdate,
  removeBraces,
  removeParentheses,
  select,
  transform,
  update,
  clip,
  validateRect
};

},{"./prepared-select-funcs.js":50,"./prepared-update-funcs.js":51,"iter-fun":48}]},{},[2]);
